---
/**
 * OAuth Callback Page
 * Handles the redirect from Supabase OAuth (Google, etc.)
 * Exchanges the code for a session and redirects to the appropriate page
 */
---

<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Anmeldung wird verarbeitet...</title>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
    }
    .container {
      text-align: center;
      padding: 2rem;
      max-width: 500px;
    }
    .spinner {
      width: 48px;
      height: 48px;
      border: 4px solid #e5e7eb;
      border-top-color: #10b981;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    h1 {
      color: #1f2937;
      font-size: 1.25rem;
      margin-bottom: 0.5rem;
    }
    p {
      color: #6b7280;
      font-size: 0.875rem;
    }
    .error {
      color: #dc2626;
      background: #fef2f2;
      padding: 1rem;
      border-radius: 0.5rem;
      margin-top: 1rem;
      display: none;
      text-align: left;
    }
    .error-title {
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    .error-details {
      font-size: 0.75rem;
      color: #991b1b;
      word-break: break-word;
    }
    .error-hint {
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid #fecaca;
      font-size: 0.75rem;
      color: #b91c1c;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="spinner" id="spinner"></div>
    <h1 id="title">Anmeldung wird verarbeitet...</h1>
    <p id="message">Bitte warten Sie einen Moment.</p>
    <div class="error" id="error"></div>
  </div>

  <!-- Inline script + CDN: no bundled chunk = no 404 after deploy/cache. Supabase loaded from esm.sh at runtime. -->
  <script type="module" is:inline define:vars={{ supabaseUrl: import.meta.env.PUBLIC_SUPABASE_URL || '', supabaseAnonKey: import.meta.env.PUBLIC_SUPABASE_ANON_KEY || '', apiBase: import.meta.env.PUBLIC_API_URL || '' }}>
    import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
    const supabase = createClient(supabaseUrl, supabaseAnonKey, { auth: { autoRefreshToken: true, persistSession: true, detectSessionInUrl: true } });
    const API_BASE = apiBase || window.location.origin;

    function getErrorCode(message) {
      const lowerMessage = message.toLowerCase();
      
      if (lowerMessage.includes('redirect_uri_mismatch') || lowerMessage.includes('redirect uri')) {
        return 'redirect_uri_mismatch';
      }
      if (lowerMessage.includes('invalid_grant') || lowerMessage.includes('invalid grant')) {
        return 'invalid_grant';
      }
      if (lowerMessage.includes('access_denied') || lowerMessage.includes('access denied')) {
        return 'access_denied';
      }
      if (lowerMessage.includes('unauthorized_client')) {
        return 'unauthorized_client';
      }
      if (lowerMessage.includes('invalid_client') || lowerMessage.includes('client id')) {
        return 'invalid_client';
      }
      if (lowerMessage.includes('keine session') || lowerMessage.includes('no session')) {
        return 'no_session';
      }
      if (lowerMessage.includes('pkce') || lowerMessage.includes('code verifier')) {
        return 'pkce_error';
      }
      if (lowerMessage.includes('invalid') && (lowerMessage.includes('expired') || lowerMessage.includes('token'))) {
        return 'invalid_token';
      }
      return 'unknown';
    }

    /**
     * Get user-friendly error title
     */
    function getErrorTitle(code) {
      const titles = {
        'redirect_uri_mismatch': 'Konfigurationsfehler: Redirect-URI',
        'invalid_grant': 'Ungültiger oder abgelaufener Code',
        'access_denied': 'Zugriff verweigert',
        'unauthorized_client': 'OAuth-Client nicht autorisiert',
        'invalid_client': 'Ungültige Client-ID',
        'no_session': 'Keine Session erhalten',
        'pkce_error': 'Authentifizierungs-Fehler (PKCE)',
        'invalid_token': 'Ungültiger oder abgelaufener Token',
        'ACCOUNT_SYNC_FAILED': 'Konto konnte nicht angelegt werden',
        'EMAIL_MISSING': 'Keine E-Mail-Adresse',
        'AUTH_INVALID': 'Authentifizierung ungültig',
        'DB_CONNECTION_ERROR': 'Datenbankverbindung fehlgeschlagen',
        'DB_UNAVAILABLE': 'Datenbank nicht erreichbar',
        'EMAIL_EXISTS': 'E-Mail bereits registriert',
        'SERVICE_UNAVAILABLE': 'Dienst nicht verfügbar',
        'unknown': 'Authentifizierung fehlgeschlagen',
      };
      return titles[code] || titles['unknown'];
    }

    /**
     * Get helpful hint for common errors
     */
    function getErrorHint(code) {
      const hints = {
        'redirect_uri_mismatch': 
          'Die Redirect-URI in der Google Cloud Console stimmt nicht mit der Supabase-Callback-URL überein. ' +
          'Prüfe: Google Cloud → Credentials → OAuth Client → Authorized redirect URIs muss die Supabase-Callback-URL enthalten.',
        'invalid_grant': 
          'Der Authentifizierungscode ist abgelaufen oder wurde bereits verwendet. Bitte versuche es erneut.',
        'access_denied': 
          'Du hast die Anmeldung abgebrochen oder der Zugriff wurde verweigert.',
        'unauthorized_client': 
          'Der OAuth-Client ist nicht korrekt in der Google Cloud Console konfiguriert.',
        'invalid_client': 
          'Die Client-ID in Supabase stimmt nicht mit der in der Google Cloud Console überein.',
        'no_session': 
          'Nach der Anmeldung wurde keine Session erstellt. Prüfe die Supabase-Konfiguration (Providers → Google).',
        'pkce_error': 
          'Fehler beim Code-Austausch. Bitte versuche es erneut oder lösche die Browser-Cookies für diese Seite.',
        'invalid_token': 
          'Der Anmeldelink ist abgelaufen oder wurde bereits verwendet. Bitte starte die Anmeldung erneut von der Login-Seite.',
        'ACCOUNT_SYNC_FAILED': 
          'Dein Konto konnte nicht in der Datenbank angelegt werden. Bitte versuche es erneut.',
        'EMAIL_MISSING': 
          'Google hat keine E-Mail-Adresse übermittelt. Bitte nutze den E-Mail-Login oder prüfe deine Google-Kontoeinstellungen.',
        'DB_CONNECTION_ERROR': 
          'Die Anmeldung bei Google war erfolgreich, aber die Datenbank antwortet nicht rechtzeitig. ' +
          'Bitte versuche es in ein paar Sekunden erneut. Falls das Problem anhält, prüfe die DATABASE_URL und ob die Datenbank erreichbar ist.',
        'DB_UNAVAILABLE': 
          'Die Anmeldung bei Google war erfolgreich, aber die Datenbank ist derzeit nicht erreichbar. ' +
          'Bitte versuche es später erneut oder prüfe die Datenbankverbindung (DATABASE_URL).',
        'EMAIL_EXISTS': 
          'Ein Konto mit dieser E-Mail-Adresse existiert bereits. Versuche dich mit E-Mail und Passwort anzumelden.',
        'SERVICE_UNAVAILABLE': 
          'Der Authentifizierungsdienst (Supabase) ist nicht konfiguriert. Bitte prüfe SUPABASE_URL und SUPABASE_SERVICE_ROLE_KEY im Backend.',
      };
      return hints[code] || null;
    }

    /**
     * Check if error is a configuration error (needs longer display time)
     */
    function isConfigError(err) {
      if (!(err instanceof Error)) return false;
      const code = getErrorCode(err.message);
      return ['redirect_uri_mismatch', 'unauthorized_client', 'invalid_client', 'no_session'].includes(code);
    }

    /**
     * Clean up auth state on error
     */
    async function cleanupAuthState() {
      localStorage.removeItem('auth_token');
      sessionStorage.removeItem('auth_token');
      try {
        await supabase.auth.signOut();
      } catch {
        // Ignore signOut errors
      }
    }

    async function handleCallback() {
      const titleEl = document.getElementById('title');
      const messageEl = document.getElementById('message');
      const spinnerEl = document.getElementById('spinner');
      const errorEl = document.getElementById('error');

      // For redirect after error
      let errorCode = 'auth_failed';

      try {
        const hashParams = new URLSearchParams(window.location.hash.substring(1));
        const queryParams = new URLSearchParams(window.location.search);
        
        // Debug: log what we received in the URL
        console.log('[Callback] URL:', window.location.href);
        console.log('[Callback] Query params:', Object.fromEntries(queryParams.entries()));
        console.log('[Callback] Hash params:', Object.fromEntries(hashParams.entries()));
        
        // Check for error in URL
        const error = hashParams.get('error') || queryParams.get('error');
        const errorDescription = hashParams.get('error_description') || queryParams.get('error_description');
        
        if (error) {
          throw new Error(errorDescription || error);
        }

        // PKCE Flow: Exchange code for session first
        const code = queryParams.get('code');
        let session = null;
        
        if (code) {
          console.log('[Callback] PKCE flow: exchanging code for session');
          const { data, error: exchangeError } = await supabase.auth.exchangeCodeForSession(code);
          if (exchangeError) {
            console.error('[Callback] Code exchange failed:', exchangeError);
            throw exchangeError;
          }
          session = data.session;
          console.log('[Callback] Code exchange successful, session:', !!session);
        } else {
          // Implicit flow: token in URL hash
          const accessToken = hashParams.get('access_token');
          const refreshToken = hashParams.get('refresh_token');
          if (accessToken) {
            console.log('[Callback] Implicit flow: setting session from hash');
            const { data, error: setErr } = await supabase.auth.setSession({
              access_token: accessToken,
              refresh_token: refreshToken || ''
            });
            if (setErr) {
              console.error('[Callback] setSession failed:', setErr);
              throw setErr;
            }
            session = data.session;
            console.log('[Callback] setSession successful, session:', !!session);
          } else {
            // No code and no access_token - check if Supabase already has a session
            // (e.g. from detectSessionInUrl or a previous login)
            console.log('[Callback] No code or token in URL, checking existing session');
            const { data: existingData, error: existingError } = await supabase.auth.getSession();
            if (existingError) {
              console.error('[Callback] getSession error:', existingError);
              throw existingError;
            }
            session = existingData.session;
            console.log('[Callback] Existing session:', !!session);
          }
        }

        if (!session) {
          // Log detailed info for debugging
          console.error('[Callback] No session obtained. URL was:', window.location.href);
          throw new Error('Auth session missing! Keine Authentifizierungsdaten in der URL gefunden. Bitte versuche es erneut von der Login-Seite.');
        }

        // Check if "remember me" was selected (stored before OAuth redirect)
        const remember = localStorage.getItem('auth_remember') !== 'false';
        localStorage.removeItem('auth_remember');

        // Store token based on "remember me" preference
        if (remember) {
          localStorage.setItem('auth_token', session.access_token);
        } else {
          sessionStorage.setItem('auth_token', session.access_token);
        }

        // Update UI - syncing
        if (messageEl) messageEl.textContent = 'Konto wird synchronisiert...';

        // Sync user to backend database (Prisma user must exist before login is complete)
        const syncUrl = `${API_BASE || window.location.origin}/api/auth/sync`;
        console.log('[Callback] Syncing user to backend:', syncUrl);

        // Retry logic for transient database errors (P2024 connection timeout, P1001/P1002 unreachable)
        const RETRYABLE_CODES = ['DB_CONNECTION_ERROR', 'DB_UNAVAILABLE'];
        const MAX_RETRIES = 2;
        const SYNC_TIMEOUT_MS = 15000; // 15 seconds per attempt
        let syncResponse = null;
        let lastSyncData = null;

        for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
          if (attempt > 0) {
            console.log(`[Callback] Sync retry ${attempt}/${MAX_RETRIES}...`);
            if (messageEl) messageEl.textContent = `Erneuter Verbindungsversuch (${attempt}/${MAX_RETRIES})...`;
            // Exponential backoff: 1s, 2s
            await new Promise(r => setTimeout(r, attempt * 1000));
          }

          try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), SYNC_TIMEOUT_MS);

            syncResponse = await fetch(syncUrl, {
              method: 'POST',
              headers: { 'Authorization': `Bearer ${session.access_token}` },
              signal: controller.signal
            });

            clearTimeout(timeoutId);
            console.log('[Callback] Sync response:', syncResponse.status);
          } catch (fetchErr) {
            console.error('[Callback] Sync fetch error:', fetchErr.name, fetchErr.message);
            if (fetchErr.name === 'AbortError') {
              // Timeout - retry if we have attempts left
              if (attempt < MAX_RETRIES) continue;
              errorCode = 'DB_CONNECTION_ERROR';
              await cleanupAuthState();
              throw new Error('Backend antwortet nicht (Timeout). Bitte versuche es erneut.');
            }
            // Network error (CORS, offline, etc.)
            if (attempt < MAX_RETRIES) continue;
            errorCode = 'ACCOUNT_SYNC_FAILED';
            await cleanupAuthState();
            throw new Error(`Backend nicht erreichbar: ${fetchErr.message}`);
          }

          if (syncResponse.ok) break;

          lastSyncData = await syncResponse.json().catch(() => ({}));
          const syncErrorCode = lastSyncData.error?.code || 'ACCOUNT_SYNC_FAILED';
          console.log('[Callback] Sync error:', syncErrorCode, lastSyncData.error?.message);

          // Only retry on transient database errors
          if (!RETRYABLE_CODES.includes(syncErrorCode) || attempt === MAX_RETRIES) {
            errorCode = syncErrorCode;
            await cleanupAuthState();
            throw new Error(lastSyncData.error?.message || 'Konto konnte nicht synchronisiert werden');
          }
        }

        // Update UI - success
        if (titleEl) titleEl.textContent = 'Anmeldung erfolgreich!';
        if (messageEl) messageEl.textContent = 'Du wirst weitergeleitet...';
        if (spinnerEl) spinnerEl.style.borderTopColor = '#10b981';

        // Redirect
        const redirectTo = localStorage.getItem('auth_redirect') || '/';
        localStorage.removeItem('auth_redirect');
        setTimeout(() => {
          window.location.href = redirectTo;
        }, 1000);

      } catch (err) {
        if (spinnerEl) spinnerEl.style.display = 'none';
        if (titleEl) titleEl.textContent = 'Anmeldung fehlgeschlagen';
        if (messageEl) messageEl.textContent = 'Es gab ein Problem bei der Anmeldung.';
        
        if (errorEl) {
          const errorMessage = err instanceof Error ? err.message : 'Unbekannter Fehler';
          const displayCode = getErrorCode(errorMessage) !== 'unknown' ? getErrorCode(errorMessage) : errorCode;
          const errorHint = getErrorHint(displayCode);
          
          errorEl.style.display = 'block';
          errorEl.innerHTML = `
            <div class="error-title">${getErrorTitle(displayCode)}</div>
            <div class="error-details">${errorMessage}</div>
            ${errorHint ? `<div class="error-hint">${errorHint}</div>` : ''}
          `;
        }

        // Clean up auth state on any error
        await cleanupAuthState();

        // Redirect to login after delay (longer for config errors)
        const redirectDelay = isConfigError(err) ? 8000 : 3000;
        setTimeout(() => {
          window.location.href = `/login?error=${errorCode}`;
        }, redirectDelay);
      }
    }

    // Run on page load
    handleCallback();
  </script>
</body>
</html>

---
import AdminLayout from '../../layouts/AdminLayout.astro';
const API_URL = import.meta.env.PUBLIC_API_URL || 'http://localhost:4000';
---

<AdminLayout title="AI Worker - kiezling Admin" currentPage="ai-worker">
  <div class="max-w-7xl mx-auto">
    <!-- Header -->
    <header class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4 mb-6">
      <div>
        <h1 class="text-2xl font-bold text-gray-900">AI Worker</h1>
        <p class="text-gray-500 text-sm mt-1">Pending-Events klassifizieren und Status setzen</p>
      </div>
      <div class="flex items-center gap-3 flex-wrap">
        <div id="cost-badge" class="hidden px-3 py-1.5 rounded-full bg-purple-100 text-purple-700 text-sm font-medium">
          <span id="total-cost">$0.00</span>
        </div>
        <div id="health-badge" class="flex items-center gap-2 px-3 py-1.5 rounded-full bg-gray-100 text-gray-500 text-sm font-medium">
          <span id="health-dot" class="w-2 h-2 rounded-full bg-gray-400"></span>
          <span id="health-text">Pruefe...</span>
        </div>
        <!-- Diagnose inline: Worker, Redis, OpenAI -->
        <div id="diagnostics-inline" class="flex items-center gap-2 flex-wrap">
          <div id="diag-worker" class="flex items-center gap-1.5 px-2.5 py-1 rounded-full bg-gray-50 text-xs">
            <span id="diag-worker-dot" class="w-1.5 h-1.5 rounded-full bg-gray-400"></span>
            <span id="diag-worker-status">Worker …</span>
          </div>
          <div id="diag-redis" class="flex items-center gap-1.5 px-2.5 py-1 rounded-full bg-gray-50 text-xs">
            <span id="diag-redis-dot" class="w-1.5 h-1.5 rounded-full bg-gray-400"></span>
            <span id="diag-redis-status">Redis …</span>
          </div>
          <div id="diag-openai" class="flex items-center gap-1.5 px-2.5 py-1 rounded-full bg-gray-50 text-xs">
            <span id="diag-openai-dot" class="w-1.5 h-1.5 rounded-full bg-gray-400"></span>
            <span id="diag-openai-status">OpenAI …</span>
          </div>
        </div>
      </div>
    </header>

    <!-- Loading State -->
    <div id="loading-state" class="text-center py-12">
      <div class="animate-spin inline-block w-8 h-8 border-4 border-primary-500 border-t-transparent rounded-full"></div>
      <p class="text-gray-500 mt-4">Lade Status...</p>
    </div>

    <!-- Content -->
    <div id="content" class="hidden space-y-6">
      <!-- Stats Row -->
      <div class="grid grid-cols-2 lg:grid-cols-5 gap-4">
        <div id="pending-card" class="bg-white rounded-2xl shadow-card p-4 border-l-4 border-gray-300">
          <p class="text-xs text-gray-500 font-medium">Pending AI</p>
          <p id="pending-ai-count" class="text-2xl font-bold text-gray-900 mt-1">--</p>
        </div>
        <div class="bg-white rounded-2xl shadow-card p-4">
          <p class="text-xs text-gray-500">Heute verarbeitet</p>
          <p id="processed-today" class="text-2xl font-bold text-gray-900 mt-1">--</p>
        </div>
        <div class="bg-white rounded-2xl shadow-card p-4">
          <p class="text-xs text-gray-500">Erfolgsrate</p>
          <p id="success-rate" class="text-2xl font-bold text-gray-900 mt-1">--%</p>
        </div>
        <div class="bg-white rounded-2xl shadow-card p-4">
          <p class="text-xs text-gray-500">Ø Zeit/Event</p>
          <p id="avg-time" class="text-2xl font-bold text-gray-900 mt-1">--</p>
        </div>
        <div class="bg-white rounded-2xl shadow-card p-4">
          <p class="text-xs text-gray-500">Letzte Aktivitaet</p>
          <p id="last-processed-at" class="text-lg font-bold text-gray-900 mt-1">--</p>
        </div>
      </div>

      <!-- Kosten heute (Live) -->
      <div class="bg-white rounded-2xl shadow-card p-4 border border-purple-100">
        <div class="flex items-center justify-between mb-3">
          <h2 class="text-sm font-semibold text-gray-800">Kosten heute (AI-Anfragen)</h2>
          <span id="cost-today-updated" class="text-xs text-gray-400">--</span>
        </div>
        <div id="cost-today-root" class="flex flex-wrap gap-4 items-baseline">
          <div class="flex items-baseline gap-2">
            <span id="cost-today-total" class="text-2xl font-bold text-purple-600">$0.00</span>
            <span id="cost-today-calls" class="text-sm text-gray-500">0 Anfragen</span>
          </div>
          <span id="cost-today-remaining" class="text-sm text-gray-500">Verbleibend: --</span>
          <div id="cost-today-by-op" class="text-sm text-gray-600 hidden"></div>
        </div>
        <div id="cost-today-recent-wrap" class="mt-3 hidden">
          <p class="text-xs font-medium text-gray-500 mb-1">Letzte Anfragen</p>
          <div id="cost-today-recent" class="max-h-32 overflow-y-auto rounded-lg bg-gray-50 p-2 text-xs font-mono"></div>
        </div>
        <p id="cost-today-error" class="mt-2 text-sm text-red-600 hidden"></p>
      </div>

      <!-- Batch Processing Controls -->
      <div class="bg-white rounded-2xl shadow-card p-6">
        <div class="flex flex-col gap-4">
          <div class="flex flex-col sm:flex-row sm:items-end gap-4 flex-wrap">
            <div class="flex-1 min-w-[180px]">
              <label for="batch-source-select" class="block text-sm font-medium text-gray-700 mb-1">Quelle</label>
              <select 
                id="batch-source-select" 
                class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500 outline-none text-sm bg-white"
              >
                <option value="">Alle Quellen</option>
              </select>
              <p id="batch-source-count" class="text-sm text-gray-500 mt-1 hidden"></p>
            </div>
            <div class="flex-1">
              <div class="flex items-center justify-between mb-2">
                <label for="batch-slider" class="text-sm font-medium text-gray-700">Batch-Groesse</label>
                <span id="slider-value" class="text-sm font-bold text-primary-600 bg-primary-50 px-2 py-0.5 rounded">1</span>
              </div>
              <input 
                type="range" 
                id="batch-slider" 
                min="1" 
                max="100" 
                value="1" 
                step="1"
                class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider-thumb"
              />
            </div>
            <button 
              id="start-batch-btn" 
              class="px-6 py-3 bg-primary-500 hover:bg-primary-600 disabled:bg-gray-300 disabled:cursor-not-allowed text-white font-semibold rounded-xl transition-colors flex items-center gap-2"
            >
              <span id="btn-icon">&#x1F680;</span>
              <span id="btn-text">Start Batch</span>
            </button>
          </div>
          <div class="flex items-center gap-2">
            <input type="checkbox" id="batch-force-crawl-first" class="w-4 h-4 text-primary-500 border-gray-300 rounded focus:ring-primary-500" />
            <label for="batch-force-crawl-first" class="text-sm text-gray-700">Vorher Website crawlen (fehlende Felder auffuellen, dann AI)</label>
          </div>
        </div>
        <p id="btn-hint" class="text-sm text-gray-500 mt-2 hidden"></p>
        <div id="no-pending-hint" class="hidden mt-3 p-3 bg-blue-50 border border-blue-200 rounded-lg text-sm text-blue-800">
          <strong>Warum keine Batches?</strong> Es gibt aktuell keine Events mit Status &quot;Pending AI&quot;. Neue solche Events entstehen durch <strong>Crawl/Ingest</strong> (Quellen crawlen). Sobald neue Rohdaten reinkommen, erscheinen sie hier und koennen verarbeitet werden.
        </div>
      </div>

      <!-- Progress Bar (shown during processing) -->
      <div id="progress-section" class="hidden bg-white rounded-2xl shadow-card p-4">
        <div id="progress-current-banner" class="hidden mb-2 p-2 rounded-lg bg-primary-50 border border-primary-200 text-sm text-primary-800">
          <span id="progress-current-text">Event 1 von 1 wird bearbeitet:</span> <strong id="progress-current-title" class="truncate block"></strong>
        </div>
        <div class="flex items-center justify-between mb-2">
          <div class="flex items-center gap-4">
            <span id="progress-text" class="text-sm text-gray-600">0 / 0</span>
            <span id="progress-percent" class="text-sm font-bold text-primary-600">0%</span>
            <span id="elapsed-time" class="text-sm text-gray-400">0:00</span>
            <!-- Heartbeat Indicator -->
            <span id="heartbeat-indicator" class="flex items-center gap-1.5 text-xs px-2 py-1 rounded-full bg-green-100 text-green-700">
              <span id="heartbeat-dot" class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span>
              <span id="heartbeat-text">Aktiv</span>
            </span>
          </div>
          <div class="flex items-center gap-3">
            <!-- Summary badges -->
            <span class="text-xs px-2 py-1 rounded-full bg-green-100 text-green-700">
              <span id="stat-published">0</span> published
            </span>
            <span class="text-xs px-2 py-1 rounded-full bg-amber-100 text-amber-700">
              <span id="stat-review">0</span> review
            </span>
            <span class="text-xs px-2 py-1 rounded-full bg-red-100 text-red-700">
              <span id="stat-failed">0</span> failed
            </span>
            <button id="cancel-btn" class="px-3 py-1 text-sm text-red-600 hover:bg-red-50 rounded-lg transition-colors">
              Abbrechen
            </button>
          </div>
        </div>
        <div class="w-full bg-gray-200 rounded-full h-2 overflow-hidden">
          <div id="progress-bar" class="bg-primary-500 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
        <div id="redis-unavailable-banner" class="hidden mt-3 p-3 bg-amber-50 border border-amber-200 rounded-lg text-sm text-amber-800">
          <strong>Live-Fortschritt nicht verfuegbar.</strong> Redis ist nicht konfiguriert. Der Batch laeuft im Hintergrund weiter. Seite in ein paar Minuten neu laden fuer die Ergebnisse.
        </div>
        <div id="stale-job-banner" class="hidden mt-3 p-3 bg-red-50 border border-red-200 rounded-lg text-sm text-red-800">
          <strong>Job moeglicherweise gestoppt.</strong> Kein Heartbeat seit ueber 5 Minuten. Der Job wurde eventuell unterbrochen.
          <button id="retry-stale-btn" class="ml-2 underline hover:no-underline">Job abbrechen und neu starten</button>
        </div>
      </div>

      <!-- Event Pipeline (Split-View) – dauerhaft sichtbar; beim Start Batch gehen Events hier rein -->
      <div id="pipeline-section">
        <div class="flex gap-4 min-h-[75vh]">
          <!-- Left: Event List -->
          <div class="w-80 flex-shrink-0 bg-white rounded-2xl shadow-card flex flex-col">
            <div class="p-4 border-b border-gray-100">
              <h3 class="font-semibold text-gray-900">Event Pipeline</h3>
              <p class="text-xs text-gray-500 mt-1"><span id="list-count">0</span> Events</p>
            </div>
            <div id="event-list" class="flex-1 overflow-y-auto p-2 space-y-1">
              <!-- Event items will be inserted here -->
            </div>
          </div>

          <!-- Right: Detail Panel -->
          <div class="flex-1 bg-white rounded-2xl shadow-card flex flex-col overflow-hidden">
            <div id="detail-panel" class="flex-1 overflow-y-auto">
              <!-- Empty state -->
              <div id="detail-empty" class="flex items-center justify-center h-full text-gray-400">
                <div class="text-center">
                  <div class="text-4xl mb-2">&#x1F50D;</div>
                  <p>Waehle ein Event aus der Liste</p>
                </div>
              </div>
              <!-- Detail content (hidden by default) -->
              <div id="detail-content" class="hidden p-6 space-y-6">
                <!-- Header -->
                <div>
                  <div class="flex items-start justify-between gap-4">
                    <div class="min-w-0 flex-1">
                      <div class="flex items-center gap-2">
                        <h2 id="detail-title" class="text-xl font-bold text-gray-900 truncate">Event Title</h2>
                        <button id="copy-event-id" class="copy-btn" title="Event-ID kopieren">&#x1F4CB;</button>
                      </div>
                      <a id="detail-source-link" href="#" target="_blank" class="text-sm text-primary-600 hover:underline truncate block">
                        <span id="detail-source-name">Quelle</span>
                      </a>
                    </div>
                    <div class="flex items-center gap-2">
                      <span id="detail-source-type-badge" class="px-2 py-0.5 rounded text-xs font-medium bg-gray-100 text-gray-600"></span>
                      <div id="detail-status-badge" class="flex-shrink-0 px-3 py-1 rounded-full text-sm font-medium">waiting</div>
                    </div>
                  </div>
                </div>

                <!-- Suggested Actions (Next Steps) -->
                <div id="section-actions" class="hidden">
                  <div class="p-3 bg-blue-50 border border-blue-200 rounded-lg">
                    <p class="text-sm font-semibold text-blue-800 mb-2">Empfohlene naechste Schritte</p>
                    <div id="actions-list" class="flex flex-wrap gap-2"></div>
                  </div>
                </div>

                <!-- Validation Checks (Ampel) -->
                <div id="section-checks" class="hidden">
                  <div class="flex items-center gap-2 mb-2">
                    <span class="text-sm font-semibold text-gray-700">Checks</span>
                    <span id="checks-summary" class="text-xs px-2 py-0.5 rounded-full"></span>
                  </div>
                  <div id="checks-list" class="hidden space-y-1"></div>
                </div>

                <!-- Missing fields warning -->
                <div id="detail-missing" class="hidden p-3 bg-amber-50 rounded-lg">
                  <p class="text-sm text-amber-700 font-medium">Fehlende Felder:</p>
                  <p id="detail-missing-list" class="text-sm text-amber-600 mt-1"></p>
                </div>

                <!-- Smart Crawl UI -->
                <div id="section-crawl" class="hidden">
                  <div class="p-4 bg-gray-50 border border-gray-200 rounded-lg">
                    <div class="flex items-center justify-between mb-2">
                      <span class="text-sm font-semibold text-gray-700">Website Crawl</span>
                      <span id="crawl-status-badge" class="text-xs px-2 py-0.5 rounded-full"></span>
                    </div>
                    <div id="crawl-url-display" class="flex items-center gap-2 mb-3">
                      <span class="text-xs text-gray-500">URL:</span>
                      <a id="crawl-url-link" href="#" target="_blank" class="text-xs text-primary-600 hover:underline truncate"></a>
                      <button id="copy-crawl-url" class="copy-btn text-xs" title="URL kopieren">&#x1F4CB;</button>
                    </div>
                    <div id="crawl-result" class="hidden mb-3 text-xs space-y-1"></div>
                    <div class="flex items-center gap-3">
                      <button id="crawl-btn" class="px-4 py-2 bg-primary-500 text-white rounded-lg hover:bg-primary-600 font-medium transition-colors text-sm disabled:bg-gray-300 disabled:cursor-not-allowed">
                        Website crawlen
                      </button>
                      <button id="detail-trigger-ai" class="px-4 py-2 bg-amber-500 text-white rounded-lg hover:bg-amber-600 font-medium transition-colors text-sm">
                        <span id="detail-trigger-ai-text">AI erneut ausfuehren</span>
                      </button>
                      <span id="detail-trigger-ai-status" class="text-sm text-gray-500 hidden"></span>
                    </div>
                    <!-- Gecrawlte Rohdaten (ausklappbar) -->
                    <details id="crawl-raw-details" class="hidden mt-3">
                      <summary class="text-sm font-medium text-gray-700 cursor-pointer hover:text-gray-900">
                        Gecrawlte Rohdaten (Eingabe fuer AI-Worker)
                      </summary>
                      <div id="crawl-raw-content" class="mt-2 p-3 bg-white border border-gray-200 rounded text-xs space-y-2"></div>
                    </details>
                    <!-- Crawl Diagnostics (collapsible) -->
                    <details id="crawl-diagnostics" class="hidden mt-3">
                      <summary class="text-xs text-gray-500 cursor-pointer hover:text-gray-700">Crawl Diagnostics</summary>
                      <div id="crawl-diagnostics-content" class="mt-2 p-2 bg-white rounded text-xs font-mono space-y-1"></div>
                    </details>
                  </div>
                </div>

                <!-- Data Sources Timeline -->
                <div id="section-sources" class="hidden">
                  <details>
                    <summary class="text-sm font-semibold text-gray-700 cursor-pointer hover:text-gray-900 flex items-center gap-2">
                      <span>Datenquellen</span>
                      <span id="sources-count" class="text-xs px-1.5 py-0.5 rounded-full bg-gray-200 text-gray-600">0</span>
                    </summary>
                    <div id="sources-timeline" class="mt-3 space-y-3"></div>
                  </details>
                </div>

                <!-- All Fields (expanded from Basic Info) -->
                <div>
                  <h4 class="text-sm font-semibold text-gray-700 mb-3 flex items-center gap-2">
                    <span>&#x1F4CB;</span> Alle Felder
                    <span id="fields-provenance-hint" class="text-xs font-normal text-gray-400">(Badges zeigen Datenquelle)</span>
                  </h4>
                  <!-- Field groups -->
                  <div class="space-y-4">
                    <div>
                      <p class="text-xs text-gray-400 mb-2 uppercase tracking-wide">Basis</p>
                      <div class="grid grid-cols-2 gap-3" id="fields-basic"></div>
                    </div>
                    <div>
                      <p class="text-xs text-gray-400 mb-2 uppercase tracking-wide">Datum / Zeit</p>
                      <div class="grid grid-cols-2 gap-3" id="fields-datetime"></div>
                    </div>
                    <div>
                      <p class="text-xs text-gray-400 mb-2 uppercase tracking-wide">Ort</p>
                      <div class="grid grid-cols-2 gap-3" id="fields-location"></div>
                    </div>
                    <div>
                      <p class="text-xs text-gray-400 mb-2 uppercase tracking-wide">Preis</p>
                      <div class="grid grid-cols-2 gap-3" id="fields-price"></div>
                    </div>
                    <div>
                      <p class="text-xs text-gray-400 mb-2 uppercase tracking-wide">Zielgruppe</p>
                      <div class="grid grid-cols-2 gap-3" id="fields-audience"></div>
                    </div>
                    <div>
                      <p class="text-xs text-gray-400 mb-2 uppercase tracking-wide">Details</p>
                      <div class="grid grid-cols-2 gap-3" id="fields-details"></div>
                    </div>
                  </div>
                </div>

                <!-- Field Conflicts -->
                <div id="section-conflicts" class="hidden">
                  <h4 class="text-sm font-semibold text-gray-700 mb-3 flex items-center gap-2">
                    <span>&#x26A0;</span> Konflikte
                    <span id="conflicts-count" class="text-xs px-1.5 py-0.5 rounded-full bg-orange-200 text-orange-700">0</span>
                  </h4>
                  <div id="conflicts-list" class="space-y-2"></div>
                </div>

                <!-- AI Classifications -->
                <div id="section-ai" class="hidden">
                  <h4 class="text-sm font-semibold text-gray-700 mb-3 flex items-center gap-2">
                    <span>&#x1F916;</span> AI Klassifikation
                  </h4>
                  <div class="grid grid-cols-2 gap-3" id="fields-ai"></div>
                </div>

                <!-- AI Scores -->
                <div id="section-scores" class="hidden">
                  <h4 class="text-sm font-semibold text-gray-700 mb-3 flex items-center gap-2">
                    <span>&#x1F4CA;</span> AI Scores
                  </h4>
                  <div class="grid grid-cols-2 gap-3" id="fields-scores"></div>
                </div>

                <!-- Meta Info -->
                <div id="section-meta" class="hidden">
                  <h4 class="text-sm font-semibold text-gray-700 mb-3 flex items-center gap-2">
                    <span>&#x2699;</span> Verarbeitungs-Details
                  </h4>
                  <div class="grid grid-cols-4 gap-3 text-center" id="fields-meta"></div>
                </div>

                <!-- AI Run History -->
                <div id="section-ai-history" class="hidden">
                  <details>
                    <summary class="text-sm font-semibold text-gray-700 cursor-pointer hover:text-gray-900 flex items-center gap-2">
                      <span>AI Verlauf</span>
                      <span id="ai-history-count" class="text-xs px-1.5 py-0.5 rounded-full bg-purple-100 text-purple-700">0</span>
                    </summary>
                    <div id="ai-history-list" class="mt-3 space-y-2"></div>
                  </details>
                </div>

                <!-- Duplicate Candidates -->
                <div id="section-duplicates" class="hidden">
                  <details>
                    <summary class="text-sm font-semibold text-gray-700 cursor-pointer hover:text-gray-900 flex items-center gap-2">
                      <span>Moegliche Duplikate</span>
                      <span id="duplicates-count" class="text-xs px-1.5 py-0.5 rounded-full bg-yellow-200 text-yellow-700">0</span>
                    </summary>
                    <div id="duplicates-list" class="mt-3 space-y-2"></div>
                  </details>
                </div>

                <!-- Error Info -->
                <div id="section-error" class="hidden">
                  <div class="p-4 bg-red-50 rounded-lg">
                    <p class="text-sm font-medium text-red-700">Fehler bei der Verarbeitung</p>
                    <p id="error-message" class="text-sm text-red-600 mt-1"></p>
                    <p id="error-step" class="text-xs text-red-500 mt-2"></p>
                    <p id="error-hint" class="text-xs text-amber-700 mt-2 hidden"></p>
                  </div>
                </div>

                <!-- Audit Log -->
                <div id="section-audit" class="hidden">
                  <details>
                    <summary class="text-sm font-semibold text-gray-700 cursor-pointer hover:text-gray-900">Aenderungsverlauf</summary>
                    <div id="audit-list" class="mt-3 space-y-2 text-xs"></div>
                  </details>
                </div>

                <!-- Daten fuer AI-Worker (Eingabedaten-Uebersicht) – weiter unten -->
                <div id="section-input-data" class="p-4 bg-slate-50 border border-slate-200 rounded-lg">
                  <h4 class="text-sm font-semibold text-slate-700 mb-3 flex items-center gap-2">
                    <span>&#x1F4DD;</span> Daten fuer AI-Worker
                    <span class="text-xs font-normal text-slate-500">(Eingabe pro Event)</span>
                  </h4>
                  <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm">
                    <div><span class="text-slate-500">Titel:</span> <span id="input-data-title" class="font-medium text-slate-800 truncate block">--</span></div>
                    <div><span class="text-slate-500">Adresse:</span> <span id="input-data-address" class="text-slate-800 truncate block">--</span></div>
                    <div><span class="text-slate-500">Start:</span> <span id="input-data-start" class="text-slate-800">--</span></div>
                    <div><span class="text-slate-500">Ende:</span> <span id="input-data-end" class="text-slate-800">--</span></div>
                    <div><span class="text-slate-500">Preis:</span> <span id="input-data-price" class="text-slate-800">--</span></div>
                    <div><span class="text-slate-500">Indoor/Outdoor:</span> <span id="input-data-indoor-outdoor" class="text-slate-800">--</span></div>
                    <div class="col-span-2">
                      <span class="text-slate-500">Beschreibung (Auszug):</span>
                      <p id="input-data-description" class="text-slate-800 text-xs mt-1 line-clamp-3 max-h-16 overflow-hidden">--</p>
                    </div>
                  </div>
                  <!-- Daten nach Herkunft (RSS / Crawl / AI) -->
                  <div id="input-data-by-source" class="mt-4 pt-4 border-t border-slate-200 space-y-4">
                    <h5 class="text-xs font-semibold text-slate-600 uppercase tracking-wide">Daten nach Herkunft</h5>
                    <div id="input-data-from-feed" class="hidden">
                      <p class="text-xs font-medium text-slate-600 mb-1">Daten von RSS/Feed</p>
                      <div class="grid grid-cols-2 gap-x-3 gap-y-1 text-sm text-slate-800" id="input-data-from-feed-fields"></div>
                    </div>
                    <div id="input-data-from-crawl" class="hidden">
                      <p class="text-xs font-medium text-slate-600 mb-1">Daten vom Website-Crawl</p>
                      <div class="grid grid-cols-2 gap-x-3 gap-y-1 text-sm text-slate-800" id="input-data-from-crawl-fields"></div>
                    </div>
                    <div id="input-data-from-ai" class="hidden">
                      <p class="text-xs font-medium text-slate-600 mb-1">Daten von AI</p>
                      <div class="grid grid-cols-2 gap-x-3 gap-y-1 text-sm text-slate-800" id="input-data-from-ai-fields"></div>
                    </div>
                    <div id="input-data-from-manual" class="hidden">
                      <p class="text-xs font-medium text-slate-600 mb-1">Manuell</p>
                      <div class="grid grid-cols-2 gap-x-3 gap-y-1 text-sm text-slate-800" id="input-data-from-manual-fields"></div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Quick Links -->
      <div class="flex flex-wrap gap-3">
        <a href="/admin/review?status=pending_ai" class="px-4 py-2 bg-amber-100 text-amber-700 rounded-lg hover:bg-amber-200 transition-colors text-sm font-medium">
          Pending-AI Events
        </a>
        <a href="/admin/review?status=pending_review" class="px-4 py-2 bg-blue-100 text-blue-700 rounded-lg hover:bg-blue-200 transition-colors text-sm font-medium">
          Review Queue
        </a>
        <a href="/admin/ai-usage" class="px-4 py-2 bg-purple-100 text-purple-700 rounded-lg hover:bg-purple-200 transition-colors text-sm font-medium">
          AI Usage Monitor
        </a>
      </div>
    </div>

    <!-- Error State -->
    <div id="error-state" class="hidden text-center py-12 bg-white rounded-2xl shadow-card">
      <p class="text-red-500 text-lg mb-4">Fehler beim Laden</p>
      <button onclick="loadData()" class="px-4 py-2 bg-primary-500 text-white rounded-lg hover:bg-primary-600">
        Erneut versuchen
      </button>
    </div>
  </div>
</AdminLayout>

<style>
  /* Custom slider styles */
  .slider-thumb {
    -webkit-appearance: none;
    appearance: none;
  }
  
  .slider-thumb::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #4f46e5;
    cursor: pointer;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
  
  .slider-thumb::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #4f46e5;
    cursor: pointer;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }

  /* Event list item styles */
  .event-list-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    border-radius: 0.5rem;
    cursor: pointer;
    transition: all 0.15s ease;
  }
  
  .event-list-item:hover {
    background: #f3f4f6;
  }
  
  .event-list-item--selected {
    background: #e0e7ff !important;
    border-left: 3px solid #4f46e5;
  }
  
  .event-list-item--current {
    background: #fef3c7 !important;
    border: 2px solid #f59e0b;
    box-shadow: 0 0 0 1px #f59e0b;
  }
  
  .event-list-item--waiting {
    opacity: 0.7;
  }
  
  .event-list-item--processing {
    background: #fef3c7;
    border-left: 3px solid #f59e0b;
  }
  
  .event-list-item--done {
    border-left: 3px solid #10b981;
  }
  
  .event-list-item--error {
    border-left: 3px solid #ef4444;
    background: #fef2f2;
  }
  
  .event-list-item--history {
    opacity: 0.5;
  }

  /* Status indicator */
  .status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
  }
  
  .status-dot--waiting { background: #9ca3af; }
  .status-dot--processing { background: #f59e0b; animation: pulse 1s infinite; }
  .status-dot--done { background: #10b981; }
  .status-dot--error { background: #ef4444; }
  
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  /* Field styles */
  .field-card {
    padding: 0.75rem;
    border-radius: 0.5rem;
    background: #f9fafb;
  }
  
  .field-card--added {
    background: #ecfdf5;
    border: 1px solid #a7f3d0;
  }
  
  .field-card--changed {
    background: #fffbeb;
    border: 1px solid #fde68a;
  }
  
  .field-card--empty {
    background: #f9fafb;
    border: 1px dashed #d1d5db;
  }

  .ai-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    font-size: 0.625rem;
    font-weight: 600;
    color: #7c3aed;
    background: #ede9fe;
    padding: 0.125rem 0.375rem;
    border-radius: 0.25rem;
    margin-left: 0.5rem;
  }

  /* Score bar */
  .score-bar-container {
    height: 8px;
    background: #e5e7eb;
    border-radius: 4px;
    overflow: hidden;
  }
  
  .score-bar-fill {
    height: 100%;
    border-radius: 4px;
    transition: width 0.3s ease;
  }
  
  .score-bar-fill--high { background: #10b981; }
  .score-bar-fill--medium { background: #f59e0b; }
  .score-bar-fill--low { background: #ef4444; }

  /* Source badges */
  .source-badge {
    display: inline-flex;
    align-items: center;
    font-size: 0.6rem;
    font-weight: 600;
    padding: 0.1rem 0.35rem;
    border-radius: 0.2rem;
    margin-left: 0.35rem;
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }
  .source-badge--feed { background: #dbeafe; color: #1e40af; }
  .source-badge--crawl { background: #fce7f3; color: #9d174d; }
  .source-badge--ai { background: #ede9fe; color: #7c3aed; }
  .source-badge--manual { background: #fef3c7; color: #92400e; }
  .source-badge--unknown { background: #f3f4f6; color: #6b7280; }

  /* Copy button */
  .copy-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 1.5rem;
    height: 1.5rem;
    border-radius: 0.25rem;
    border: none;
    background: transparent;
    cursor: pointer;
    font-size: 0.75rem;
    opacity: 0.4;
    transition: opacity 0.15s;
  }
  .copy-btn:hover { opacity: 1; background: #f3f4f6; }

  /* Validation check styles */
  .check-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
  .check-dot--pass { background: #10b981; }
  .check-dot--warn { background: #f59e0b; }
  .check-dot--fail { background: #ef4444; }

  /* Source timeline */
  .source-card {
    border: 1px solid #e5e7eb;
    border-radius: 0.5rem;
    overflow: hidden;
  }
  .source-card-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.5rem 0.75rem;
    background: #f9fafb;
    cursor: pointer;
  }
  .source-card-header:hover { background: #f3f4f6; }
  .source-card-body { padding: 0.75rem; display: none; }
  .source-card-body.open { display: block; }

  /* Action button */
  .action-btn {
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    font-size: 0.75rem;
    padding: 0.35rem 0.75rem;
    border-radius: 0.375rem;
    border: 1px solid #bfdbfe;
    background: white;
    color: #1e40af;
    cursor: pointer;
    transition: all 0.15s;
  }
  .action-btn:hover { background: #dbeafe; }

  /* Conflict card */
  .conflict-item {
    padding: 0.5rem 0.75rem;
    border: 1px solid #fed7aa;
    border-radius: 0.375rem;
    background: #fffbeb;
  }

  /* Keyboard hint */
  .kbd-hint {
    font-size: 0.6rem;
    padding: 0.1rem 0.3rem;
    border: 1px solid #d1d5db;
    border-radius: 0.2rem;
    background: #f9fafb;
    color: #6b7280;
    font-family: monospace;
  }

  /* JSON tree */
  .json-tree { font-family: 'SF Mono', 'Fira Code', monospace; font-size: 0.7rem; line-height: 1.4; }
  .json-key { color: #0369a1; }
  .json-string { color: #059669; }
  .json-number { color: #d97706; }
  .json-null { color: #9ca3af; }
  .json-bool { color: #7c3aed; }

  /* Inline edit */
  .inline-edit-input {
    font-size: 0.875rem;
    padding: 0.25rem 0.5rem;
    border: 1px solid #d1d5db;
    border-radius: 0.25rem;
    width: 100%;
  }
  .inline-edit-input:focus {
    outline: none;
    border-color: #4f46e5;
    box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.2);
  }
</style>

<script is:inline define:vars={{ API_URL }}>
  const token = localStorage.getItem('auth_token');
  if (!token) {
    window.location.href = '/login?redirect=/admin/ai-worker';
  }

  // ========================================
  // STATE
  // ========================================
  let isProcessing = false;
  let isHistoryMode = false;
  let currentJobId = null;
  let events = [];
  let selectedEventId = null;
  let sourceDetailsCache = {}; // Cache source-details per event ID
  let pendingAiCountBySource = {}; // sourceId -> count (Pending AI)
  let selectedBulkIds = new Set(); // For bulk selection
  let startTime = null;
  let elapsedInterval = null;
  
  // Polling with exponential backoff
  const POLL_MIN_INTERVAL = 1000;
  const POLL_MAX_INTERVAL = 5000;
  let pollInterval = POLL_MIN_INTERVAL;
  let pollTimeout = null;
  let lastChangedAt = null;
  let poll503Count = 0;
  const POLL_503_MAX = 2;

  // OpenAI: Block Batch if no connection or quota exceeded
  let openaiOk = true;
  let lastPendingCount = 0;

  // Heartbeat tracking for reliability
  let lastHeartbeatStatus = 'healthy'; // 'healthy' | 'warning' | 'critical'
  let lastHeartbeatAge = 0; // seconds since last heartbeat

  // Current job progress (for pipeline banner and list labels)
  let jobProcessed = 0;
  let jobTotal = 0;
  let jobCurrentEventId = null;

  const AI_WORKER_JOB_KEY = 'ai-worker-active-job';

  // ========================================
  // DOM ELEMENTS
  // ========================================
  const el = {
    loadingState: document.getElementById('loading-state'),
    content: document.getElementById('content'),
    errorState: document.getElementById('error-state'),
    healthBadge: document.getElementById('health-badge'),
    healthDot: document.getElementById('health-dot'),
    healthText: document.getElementById('health-text'),
    costBadge: document.getElementById('cost-badge'),
    totalCost: document.getElementById('total-cost'),
    pendingCard: document.getElementById('pending-card'),
    pendingAiCount: document.getElementById('pending-ai-count'),
    processedToday: document.getElementById('processed-today'),
    successRate: document.getElementById('success-rate'),
    avgTime: document.getElementById('avg-time'),
    lastProcessedAt: document.getElementById('last-processed-at'),
    batchSlider: document.getElementById('batch-slider'),
    sliderValue: document.getElementById('slider-value'),
    startBatchBtn: document.getElementById('start-batch-btn'),
    btnIcon: document.getElementById('btn-icon'),
    btnText: document.getElementById('btn-text'),
    btnHint: document.getElementById('btn-hint'),
    noPendingHint: document.getElementById('no-pending-hint'),
    progressSection: document.getElementById('progress-section'),
    progressCurrentBanner: document.getElementById('progress-current-banner'),
    progressCurrentText: document.getElementById('progress-current-text'),
    progressCurrentTitle: document.getElementById('progress-current-title'),
    progressText: document.getElementById('progress-text'),
    progressPercent: document.getElementById('progress-percent'),
    progressBar: document.getElementById('progress-bar'),
    elapsedTime: document.getElementById('elapsed-time'),
    statPublished: document.getElementById('stat-published'),
    statReview: document.getElementById('stat-review'),
    statFailed: document.getElementById('stat-failed'),
    cancelBtn: document.getElementById('cancel-btn'),
    pipelineSection: document.getElementById('pipeline-section'),
    eventList: document.getElementById('event-list'),
    listCount: document.getElementById('list-count'),
    detailPanel: document.getElementById('detail-panel'),
    detailEmpty: document.getElementById('detail-empty'),
    detailContent: document.getElementById('detail-content'),
  };

  // ========================================
  // INITIALIZATION
  // ========================================
  el.batchSlider.addEventListener('input', (e) => {
    el.sliderValue.textContent = e.target.value;
  });

  function updateBatchSourceCountDisplay() {
    const sourceSelect = document.getElementById('batch-source-select');
    const countEl = document.getElementById('batch-source-count');
    if (!sourceSelect || !countEl) return;
    const sourceId = sourceSelect.value;
    if (!sourceId) {
      countEl.classList.add('hidden');
      countEl.textContent = '';
      return;
    }
    const n = pendingAiCountBySource[sourceId] ?? 0;
    countEl.textContent = n + ' Event(s) mit Status Pending AI';
    countEl.classList.remove('hidden');
  }

  document.getElementById('batch-source-select')?.addEventListener('change', updateBatchSourceCountDisplay);

  el.startBatchBtn.addEventListener('click', startBatch);
  el.cancelBtn.addEventListener('click', cancelProcessing);

  // Crawl button handler
  document.getElementById('crawl-btn').addEventListener('click', async () => {
    const id = selectedEventId;
    if (!id) return;
    const btn = document.getElementById('crawl-btn');
    const statusEl = document.getElementById('detail-trigger-ai-status');
    btn.disabled = true;
    btn.textContent = 'Crawle...';
    statusEl.classList.remove('hidden');
    statusEl.textContent = '';
    try {
      const res = await fetch(`${API_URL}/api/admin/events/${id}/trigger-ai`, {
        method: 'POST',
        headers: { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({ force_crawl: true }),
      });
      const data = await res.json();
      if (data && data.success !== false) {
        // Show crawl results
        const resultEl = document.getElementById('crawl-result');
        resultEl.classList.remove('hidden');
        let resultHtml = '';
        if (data.updated_fields && data.updated_fields.length > 0) {
          resultHtml += data.updated_fields.map(f => `<p class="text-green-600">&#x2705; ${f}: GEFUNDEN</p>`).join('');
        }
        if (data.failed_fields && data.failed_fields.length > 0) {
          resultHtml += data.failed_fields.map(f => `<p class="text-red-500">&#x274C; ${f.field}: ${escapeHtml(f.reason)}</p>`).join('');
        }
        resultEl.innerHTML = resultHtml || '<p class="text-gray-400">Keine Ergebnisse</p>';

        // Gecrawlte Rohdaten: ausklappbar anzeigen
        const rawDetails = document.getElementById('crawl-raw-details');
        const rawContent = document.getElementById('crawl-raw-content');
        if (data.crawl_raw && rawDetails && rawContent) {
          rawDetails.classList.remove('hidden');
          const raw = data.crawl_raw;
          let rawHtml = '';
          if (raw.url) rawHtml += `<p><span class="text-gray-500 font-medium">URL:</span> <a href="${escapeHtml(raw.url)}" target="_blank" rel="noopener" class="text-primary-600 hover:underline break-all">${escapeHtml(raw.url)}</a></p>`;
          if (raw.extraction_method) rawHtml += `<p><span class="text-gray-500 font-medium">Extraktion:</span> <span class="font-mono">${escapeHtml(raw.extraction_method)}</span></p>`;
          if (raw.error) rawHtml += `<p class="text-amber-600"><span class="font-medium">Hinweis:</span> ${escapeHtml(raw.error)}</p>`;
          rawHtml += '<p class="text-gray-500 font-medium mt-2">Gefundene Felder (Rohdaten):</p><dl class="mt-1 space-y-1 pl-2 border-l-2 border-gray-200">';
          const found = raw.fields_found || {};
          if (Object.keys(found).length === 0) {
            rawHtml += '<dd class="text-gray-400">Keine</dd>';
          } else {
            for (const [k, v] of Object.entries(found)) {
              const val = v == null ? '—' : (typeof v === 'string' ? v : JSON.stringify(v));
              rawHtml += `<dt class="text-gray-600 font-medium">${escapeHtml(k)}</dt><dd class="text-gray-800 break-words mb-1">${escapeHtml(String(val))}</dd>`;
            }
          }
          rawHtml += '</dl>';
          if (raw.fields_missing && raw.fields_missing.length > 0) {
            rawHtml += `<p class="text-gray-500 font-medium mt-2">Fehlend:</p><p class="text-gray-600">${raw.fields_missing.map(m => escapeHtml(m)).join(', ')}</p>`;
          }
          rawContent.innerHTML = rawHtml;
        } else if (rawDetails) {
          rawDetails.classList.add('hidden');
        }
        
        // Update crawl status badge
        const statusBadge = document.getElementById('crawl-status-badge');
        statusBadge.textContent = 'Gecrawlt';
        statusBadge.className = 'text-xs px-2 py-0.5 rounded-full bg-green-100 text-green-700';
        
        // Clear source details cache to force reload
        delete sourceDetailsCache[id];
        
        statusEl.textContent = `${(data.updated_fields?.length || 0)} Felder aktualisiert.`;
        statusEl.classList.add('text-green-600');
      } else {
        statusEl.textContent = data?.error || 'Fehler';
        statusEl.classList.add('text-red-600');
      }
    } catch (e) {
      statusEl.textContent = e?.message || 'Netzwerkfehler';
      statusEl.classList.add('text-red-600');
    } finally {
      btn.disabled = false;
      btn.textContent = 'Website crawlen';
    }
  });

  document.getElementById('detail-trigger-ai').addEventListener('click', async () => {
    const id = selectedEventId;
    if (!id) return;
    const btn = document.getElementById('detail-trigger-ai');
    const btnText = document.getElementById('detail-trigger-ai-text');
    const statusEl = document.getElementById('detail-trigger-ai-status');
    btn.disabled = true;
    btnText.textContent = 'Wird ausgefuehrt...';
    statusEl.classList.remove('hidden');
    statusEl.textContent = '';
    statusEl.classList.remove('text-red-600', 'text-green-600');
    try {
      const res = await fetch(`${API_URL}/api/admin/events/${id}/trigger-ai`, {
        method: 'POST',
        headers: { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({ force_crawl: false }),
      });
      const data = await res.json();
      if (data && data.success) {
        statusEl.textContent = `Fertig. ${(data.updated_fields && data.updated_fields.length) || 0} Felder aktualisiert.`;
        statusEl.classList.add('text-green-600');
        if (data.failed_fields && data.failed_fields.length) statusEl.textContent += ` ${data.failed_fields.length} fehlgeschlagen.`;
        delete sourceDetailsCache[id];
        const event = events.find(e => e.id === id);
        if (event && data.field_fill_status) {
          event.field_fill_status = data.field_fill_status;
          renderDetailPanel();
        }
      } else {
        statusEl.textContent = data?.error || 'Fehler beim Ausfuehren';
        statusEl.classList.add('text-red-600');
      }
    } catch (e) {
      statusEl.textContent = e?.message || 'Netzwerkfehler';
      statusEl.classList.add('text-red-600');
    } finally {
      btn.disabled = false;
      btnText.textContent = 'AI erneut ausfuehren';
    }
  });

  // ========================================
  // KOSTEN HEUTE (LIVE)
  // ========================================
  let costTodayInterval = null;
  async function refreshCostToday() {
    const root = document.getElementById('cost-today-root');
    const totalEl = document.getElementById('cost-today-total');
    const callsEl = document.getElementById('cost-today-calls');
    const remainingEl = document.getElementById('cost-today-remaining');
    const byOpEl = document.getElementById('cost-today-by-op');
    const recentWrap = document.getElementById('cost-today-recent-wrap');
    const recentEl = document.getElementById('cost-today-recent');
    const updatedEl = document.getElementById('cost-today-updated');
    const errEl = document.getElementById('cost-today-error');
    if (!root) return;
    try {
      const res = await fetch(`${API_URL}/api/admin/ai-worker/cost-today`, { headers: { Authorization: `Bearer ${token}` } });
      if (errEl) { errEl.classList.add('hidden'); errEl.textContent = ''; }
      if (!res.ok) {
        if (totalEl) totalEl.textContent = '--';
        if (callsEl) callsEl.textContent = 'Fehler';
        if (updatedEl) updatedEl.textContent = '';
        return;
      }
      const json = await res.json();
      const d = json.data || json;
      const total = typeof d.total_cost_usd === 'number' ? d.total_cost_usd : 0;
      const calls = d.total_calls || 0;
      const remaining = typeof d.daily_remaining_usd === 'number' ? d.daily_remaining_usd : null;
      const limit = typeof d.daily_limit_usd === 'number' ? d.daily_limit_usd : null;
      if (totalEl) totalEl.textContent = '$' + total.toFixed(4);
      if (callsEl) callsEl.textContent = calls + ' Anfragen';
      if (remainingEl) remainingEl.textContent = (remaining != null && limit != null) ? ('Verbleibend: $' + remaining.toFixed(2) + ' / ' + limit) : 'Verbleibend: --';
      if (updatedEl) updatedEl.textContent = d.updated_at ? 'Stand ' + d.updated_at.slice(11, 19) + ' UTC' : '';
      const byOp = d.by_operation || {};
      if (byOpEl && Object.keys(byOp).length) {
        byOpEl.classList.remove('hidden');
        byOpEl.textContent = Object.entries(byOp).map(([k, v]) => k + ': $' + Number(v).toFixed(4)).join(' · ');
      } else if (byOpEl) byOpEl.classList.add('hidden');
      const recent = d.recent || [];
      if (recentWrap && recentEl) {
        if (recent.length) {
          recentWrap.classList.remove('hidden');
          recentEl.innerHTML = recent.slice(0, 15).map(function (e) {
            return e.time + ' ' + e.operation + ' ' + e.model + ' $' + e.cost_usd + ' (' + e.in_tokens + '/' + e.out_tokens + ')';
          }).join('<br>');
        } else recentWrap.classList.add('hidden');
      }
    } catch (e) {
      const errMsg = e && e.message ? e.message : String(e);
      if (errEl) { errEl.classList.remove('hidden'); errEl.textContent = 'Kosten konnten nicht geladen werden: ' + errMsg; }
    }
  }

  // ========================================
  // LOAD INITIAL DATA
  // ========================================
  async function loadData() {
    el.loadingState.classList.remove('hidden');
    el.content.classList.add('hidden');
    el.errorState.classList.add('hidden');

    try {
      const [pendingRes, healthRes, statsRes, sourcesRes, pendingBySourceRes] = await Promise.all([
        fetch(`${API_URL}/api/admin/pending-ai-count`, {
          headers: { Authorization: `Bearer ${token}` }
        }),
        fetch(`${API_URL}/api/admin/ai-worker/health`, {
          headers: { Authorization: `Bearer ${token}` }
        }).catch(() => null),
        fetch(`${API_URL}/api/admin/ai-worker/stats`, {
          headers: { Authorization: `Bearer ${token}` }
        }).catch(() => null),
        fetch(`${API_URL}/api/sources`, {
          headers: { Authorization: `Bearer ${token}` }
        }).catch(() => null),
        fetch(`${API_URL}/api/sources/pending-ai-counts`, {
          headers: { Authorization: `Bearer ${token}` }
        }).catch(() => null),
      ]);

      if (!pendingRes.ok) throw new Error('Failed to load pending count');

      const pending = await pendingRes.json();
      const pendingCount = pending.data?.count || 0;
      el.pendingAiCount.textContent = pendingCount;

      // Update pending card styling und Hinweis bei 0
      if (pendingCount > 0) {
        el.pendingCard.classList.remove('border-gray-300');
        el.pendingCard.classList.add('border-amber-400');
        el.noPendingHint?.classList.add('hidden');
      } else {
        el.pendingCard.classList.remove('border-amber-400');
        el.pendingCard.classList.add('border-gray-300');
        el.noPendingHint?.classList.remove('hidden');
      }

      // Update worker health
      if (healthRes && healthRes.ok) {
        const healthData = await healthRes.json();
        const healthStatus = healthData?.data?.status;
        if (healthData.success && (healthStatus === 'healthy' || healthStatus === 'ok')) {
          setHealthStatus('ok');
        } else {
          setHealthStatus('degraded');
        }
      } else {
        setHealthStatus('error');
      }

      // Update stats
      if (statsRes && statsRes.ok) {
        const statsData = await statsRes.json();
        if (statsData.data) {
          el.processedToday.textContent = statsData.data.processedToday || 0;
          el.successRate.textContent = statsData.data.successRate ? `${statsData.data.successRate}%` : '--%';
          el.avgTime.textContent = statsData.data.avgProcessingTime ? `${statsData.data.avgProcessingTime}ms` : '--';
          
          if (statsData.data.lastProcessedAt) {
            el.lastProcessedAt.textContent = formatTimeAgo(new Date(statsData.data.lastProcessedAt));
          }
        }
      }

      updateButtonState(pendingCount);

      // Pending-AI-Counts pro Quelle (fuer Dropdown und Anzeige)
      if (pendingBySourceRes && pendingBySourceRes.ok) {
        try {
          const countsData = await pendingBySourceRes.json();
          if (countsData && typeof countsData.data === 'object' && countsData.data !== null) {
            pendingAiCountBySource = countsData.data;
          }
        } catch (_) { /* ignore */ }
      }

      // Quellen-Dropdown fuellen (mit Pending-AI-Anzahl pro Quelle)
      const sourceSelect = document.getElementById('batch-source-select');
      if (sourceSelect && sourcesRes && sourcesRes.ok) {
        const sourcesData = await sourcesRes.json();
        const sourcesList = sourcesData.data || [];
        const sumBySource = Object.values(pendingAiCountBySource).reduce((a, b) => a + b, 0);
        const totalPending = sumBySource > 0 ? sumBySource : pendingCount;
        sourceSelect.innerHTML = '<option value="">Alle Quellen (' + totalPending + ' Pending AI)</option>' +
          sourcesList.map(s => {
            const n = pendingAiCountBySource[s.id] !== undefined ? pendingAiCountBySource[s.id] : 0;
            return `<option value="${s.id}">${escapeHtml(s.name || s.id)} (${n})</option>`;
          }).join('');
        updateBatchSourceCountDisplay();
      }

      el.loadingState.classList.add('hidden');
      el.content.classList.remove('hidden');

      // Kosten heute (Live) einmal laden und alle 15s aktualisieren
      refreshCostToday();
      if (costTodayInterval) clearInterval(costTodayInterval);
      costTodayInterval = setInterval(refreshCostToday, 15000);

      // Nach Refresh: Aktiven Job vom SERVER abfragen (nicht sessionStorage)
      // Dies ist die vertrauenswuerdige Quelle - DB-basiert mit Heartbeat
      try {
        const activeJobRes = await fetch(`${API_URL}/api/admin/ai-jobs/active`, {
          headers: { Authorization: `Bearer ${token}` }
        });
        
        if (activeJobRes.ok) {
          const { data: activeJob, stale_job_id } = await activeJobRes.json();
          
          // Handle stale job warning
          if (stale_job_id) {
            showStaleJobWarning(stale_job_id);
          }
          
          if (activeJob && activeJob.status === 'running') {
            // Aktiver Job gefunden - UI wiederherstellen
            currentJobId = activeJob.id;
            events = activeJob.events || [];
            // WICHTIG: startedAt vom Server nutzen fuer korrekte Laufzeit
            startTime = activeJob.startedAt ? new Date(activeJob.startedAt).getTime() : 
                        (activeJob.started_at ? new Date(activeJob.started_at).getTime() : Date.now());
            lastChangedAt = activeJob.last_updated_at || null;
            poll503Count = 0;
            lastHeartbeatStatus = activeJob.heartbeat_status || 'healthy';
            lastHeartbeatAge = activeJob.heartbeat_age_seconds || 0;
            
            document.getElementById('redis-unavailable-banner')?.classList.add('hidden');
            
            showPipeline();
            updateFromJobStatus(activeJob);
            renderEventList();
            updateHeartbeatIndicator(lastHeartbeatStatus, lastHeartbeatAge);
            
            // Sofort korrekte Laufzeit anzeigen (nicht 0:00)
            updateElapsedTime();
            
            const selectId = activeJob.currentEventId || (events[0] && events[0].id);
            if (selectId) selectEvent(selectId); else if (events[0]) selectEvent(events[0].id);
            el.listCount.textContent = events.length;
            
            isProcessing = true;
            el.startBatchBtn.disabled = true;
            el.btnIcon.innerHTML = '&#x23F3;';
            el.btnText.textContent = 'Verarbeite...';
            startPolling();
            startElapsedTimer();
            
            console.log(`Restored active job ${currentJobId} from server (heartbeat: ${lastHeartbeatStatus})`);
          }
        }
        
        // Fallback: sessionStorage fuer abgeschlossene Jobs (Historie)
        const stored = sessionStorage.getItem(AI_WORKER_JOB_KEY);
        if (stored && !isProcessing) {
          const { jobId: savedJobId } = JSON.parse(stored);
          if (savedJobId) {
            const jobRes = await fetch(`${API_URL}/api/admin/ai-job-status/${savedJobId}`, {
              headers: { Authorization: `Bearer ${token}` }
            });
            if (jobRes.ok) {
              const { data: jobData } = await jobRes.json();
              if (jobData && jobData.events && jobData.events.length > 0 && 
                  (jobData.status === 'completed' || jobData.status === 'failed')) {
                // Zeige abgeschlossenen Job als Historie
                currentJobId = jobData.id;
                events = jobData.events;
                isHistoryMode = true;
                
                showPipeline();
                updateFromJobStatus(jobData);
                renderEventList();
                const selectId = events[0]?.id;
                if (selectId) selectEvent(selectId);
                el.listCount.textContent = events.length;
                
                setTimeout(() => { el.progressSection.classList.add('hidden'); }, 500);
                sessionStorage.removeItem(AI_WORKER_JOB_KEY);
              } else {
                sessionStorage.removeItem(AI_WORKER_JOB_KEY);
              }
            } else {
              sessionStorage.removeItem(AI_WORKER_JOB_KEY);
            }
          }
        }
      } catch (restoreErr) {
        console.warn('Restore job failed:', restoreErr);
        try { sessionStorage.removeItem(AI_WORKER_JOB_KEY); } catch (e) { /* ignore */ }
      }
      // Pipeline ist dauerhaft sichtbar: Leerzustand anzeigen, falls noch keine Events
      renderEventList();
    } catch (e) {
      console.error('Load error:', e);
      el.loadingState.classList.add('hidden');
      el.errorState.classList.remove('hidden');
    }
  }

  function setHealthStatus(status) {
    const classes = {
      ok: ['bg-green-100', 'text-green-700'],
      degraded: ['bg-amber-100', 'text-amber-700'],
      error: ['bg-red-100', 'text-red-700'],
    };
    const dotClasses = {
      ok: 'bg-green-500',
      degraded: 'bg-amber-500',
      error: 'bg-red-500',
    };
    const texts = { ok: 'OK', degraded: 'Eingeschraenkt', error: 'Offline' };
    
    el.healthBadge.className = `flex items-center gap-2 px-3 py-1.5 rounded-full text-sm font-medium ${classes[status].join(' ')}`;
    el.healthDot.className = `w-2 h-2 rounded-full ${dotClasses[status]}`;
    el.healthText.textContent = texts[status];
  }

  function formatTimeAgo(date) {
    const diffMs = Date.now() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);
    
    if (diffMins < 1) return 'gerade eben';
    if (diffMins < 60) return `vor ${diffMins}m`;
    if (diffHours < 24) return `vor ${diffHours}h`;
    return `vor ${diffDays}d`;
  }

  // ========================================
  // HEARTBEAT INDICATOR (Vertrauenswuerdigkeit)
  // ========================================
  function updateHeartbeatIndicator(status, ageSeconds) {
    lastHeartbeatStatus = status;
    lastHeartbeatAge = ageSeconds;
    
    const indicator = document.getElementById('heartbeat-indicator');
    const dot = document.getElementById('heartbeat-dot');
    const text = document.getElementById('heartbeat-text');
    const staleBanner = document.getElementById('stale-job-banner');
    
    if (!indicator || !dot || !text) return;
    
    // Update based on status
    if (status === 'healthy') {
      indicator.className = 'flex items-center gap-1.5 text-xs px-2 py-1 rounded-full bg-green-100 text-green-700';
      dot.className = 'w-2 h-2 rounded-full bg-green-500 animate-pulse';
      text.textContent = 'Aktiv';
      staleBanner?.classList.add('hidden');
    } else if (status === 'warning') {
      const mins = Math.floor(ageSeconds / 60);
      indicator.className = 'flex items-center gap-1.5 text-xs px-2 py-1 rounded-full bg-amber-100 text-amber-700';
      dot.className = 'w-2 h-2 rounded-full bg-amber-500 animate-pulse';
      text.textContent = `Heartbeat vor ${mins}m`;
      staleBanner?.classList.add('hidden');
    } else if (status === 'critical') {
      const mins = Math.floor(ageSeconds / 60);
      indicator.className = 'flex items-center gap-1.5 text-xs px-2 py-1 rounded-full bg-red-100 text-red-700';
      dot.className = 'w-2 h-2 rounded-full bg-red-500';
      text.textContent = `Gestoppt? (${mins}m)`;
      staleBanner?.classList.remove('hidden');
    }
  }

  function showStaleJobWarning(staleJobId) {
    const staleBanner = document.getElementById('stale-job-banner');
    if (staleBanner) {
      staleBanner.classList.remove('hidden');
      // Setup retry button
      const retryBtn = document.getElementById('retry-stale-btn');
      if (retryBtn) {
        retryBtn.onclick = async () => {
          try {
            // Cancel the stale job
            await fetch(`${API_URL}/api/admin/ai-jobs/${staleJobId}/cancel`, {
              method: 'POST',
              headers: { Authorization: `Bearer ${token}` }
            });
            staleBanner.classList.add('hidden');
            window.location.reload();
          } catch (e) {
            console.error('Failed to cancel stale job:', e);
          }
        };
      }
    }
  }

  function updateButtonState(pendingCount) {
    lastPendingCount = pendingCount;
    if (isProcessing) {
      el.startBatchBtn.disabled = true;
      el.btnHint.textContent = 'Verarbeitung laeuft...';
      el.btnHint.classList.remove('hidden');
    } else if (!openaiOk) {
      el.startBatchBtn.disabled = true;
      el.btnHint.textContent = 'OpenAI nicht verfuegbar – Batch nicht moeglich';
      el.btnHint.classList.remove('hidden');
    } else if (pendingCount === 0) {
      el.startBatchBtn.disabled = true;
      el.btnHint.textContent = 'Keine Events in der Queue';
      el.btnHint.classList.remove('hidden');
    } else {
      el.startBatchBtn.disabled = false;
      el.btnHint.classList.add('hidden');
    }
  }

  // ========================================
  // BATCH PROCESSING
  // ========================================
  async function startBatch() {
    if (isProcessing) return;

    const limit = el.batchSlider.value;
    const sourceSelect = document.getElementById('batch-source-select');
    const sourceId = sourceSelect ? sourceSelect.value : '';
    const forceCrawlFirst = document.getElementById('batch-force-crawl-first')?.checked === true;

    // Pruefen ob AI Worker erreichbar ist – sonst Hinweis anzeigen
    try {
      const healthRes = await fetch(`${API_URL}/api/admin/ai-worker/health`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      const healthData = healthRes.ok ? await healthRes.json() : null;
      const status = healthData?.data?.status;
      const workerOk = healthData?.success && (status === 'healthy' || status === 'ok');
      if (!workerOk) {
        const goAnyway = confirm(
          'AI Worker ist nicht erreichbar (Offline oder falsche AI_WORKER_URL).\n\n' +
          'Der Batch wuerde bei jedem Event fehlschlagen.\n\n' +
          'Bitte starten Sie den AI Worker zuerst (z.B. ai-worker/start.bat oder Deployment pruefen).\n\n' +
          'Trotzdem starten?'
        );
        if (!goAnyway) return;
      }
    } catch (e) {
      const goAnyway = confirm(
        'AI Worker-Status konnte nicht geprueft werden.\n\nTrotzdem Batch starten?'
      );
      if (!goAnyway) return;
    }

    // OpenAI: Keine Verbindung oder Kontingent ausgeschoepft → Batch blockieren, Fehler anzeigen
    try {
      const diagRes = await fetch(`${API_URL}/api/admin/ai-worker/diagnostics`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      if (diagRes.ok) {
        const { data } = await diagRes.json();
        const openaiCheck = data?.checks?.openai;
        if (openaiCheck && openaiCheck.status !== 'ok') {
          const err = (openaiCheck.error || '').toLowerCase();
          const isQuota = err.includes('429') || err.includes('quota') || err.includes('insufficient_quota');
          const msg = isQuota
            ? 'Das OpenAI-Kontingent ist ausgeschoepft.\n\nBitte pruefen Sie Ihr Billing unter platform.openai.com und erhoehen Sie das Limit oder laden Sie Guthaben auf.\n\nEin Start des Batches ist derzeit nicht moeglich.'
            : 'Es besteht keine Verbindung zu OpenAI (API-Key, Netzwerk oder Service ausgefallen).\n\nBitte pruefen Sie die Konfiguration des AI Workers (OPENAI_API_KEY) und die Erreichbarkeit von api.openai.com.\n\nEin Start des Batches ist derzeit nicht moeglich.';
          alert(msg);
          return;
        }
      }
    } catch (e) {
      alert('Die OpenAI-Verfuegbarkeit konnte nicht geprueft werden. Bitte versuchen Sie es spaeter erneut.');
      return;
    }

    isProcessing = true;
    isHistoryMode = false;
    el.startBatchBtn.disabled = true;
    el.btnIcon.innerHTML = '&#x23F3;';
    el.btnText.textContent = 'Startet...';
    el.btnHint.classList.add('hidden');

    try {
      const params = new URLSearchParams();
      params.set('limit', String(limit));
      if (sourceId) params.set('source_id', sourceId);
      if (forceCrawlFirst) params.set('force_crawl_first', 'true');
      const res = await fetch(`${API_URL}/api/admin/process-pending-ai?${params.toString()}`, {
        method: 'POST',
        headers: { 
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      const data = await res.json();

      if (!res.ok) {
        // Handle 409 Conflict - Job already running
        if (res.status === 409 && data.activeJobId) {
          alert(`Ein AI-Batch laeuft bereits (Job: ${data.activeJobId}). ${data.message || ''}`);
          // Reload to show the running job
          window.location.reload();
          return;
        }
        throw new Error(data.error || 'Processing failed');
      }

      if (data.jobId && data.events && data.events.length > 0) {
        currentJobId = data.jobId;
        events = data.events;
        startTime = Date.now();
        lastChangedAt = null;
        pollInterval = POLL_MIN_INTERVAL;
        poll503Count = 0;
        lastHeartbeatStatus = 'healthy';
        lastHeartbeatAge = 0;
        document.getElementById('redis-unavailable-banner')?.classList.add('hidden');
        document.getElementById('stale-job-banner')?.classList.add('hidden');
        
        try {
          sessionStorage.setItem(AI_WORKER_JOB_KEY, JSON.stringify({ jobId: data.jobId, startedAt: startTime }));
        } catch (e) { /* ignore */ }
        
        showPipeline();
        renderEventList();
        selectEvent(events[0].id);
        updateHeartbeatIndicator('healthy', 0);
        startPolling();
        startElapsedTimer();
        
        el.btnText.textContent = 'Verarbeite...';
      } else {
        const count = data.pending_ai_count ?? 0;
        const hint = data.hint || 'Neue Events entstehen durch Crawl/Ingest (Quellen crawlen).';
        alert(`Keine Events zu verarbeiten.\n\nAktuell ${count} Event(s) mit Status "Pending AI".\n\n${hint}`);
        resetButton();
      }

    } catch (e) {
      console.error('Processing error:', e);
      alert('Fehler bei der Verarbeitung: ' + e.message);
      resetButton();
    }
  }

  function showPipeline() {
    el.progressSection.classList.remove('hidden');
    // pipelineSection ist dauerhaft sichtbar
    el.progressBar.style.width = '0%';
    el.progressText.textContent = `0 / ${events.length}`;
    el.progressPercent.textContent = '0%';
    el.statPublished.textContent = '0';
    el.statReview.textContent = '0';
    el.statFailed.textContent = '0';
    el.elapsedTime.textContent = '0:00';
    el.listCount.textContent = events.length;
    el.costBadge.classList.add('hidden');
  }

  function getPipelineStatusLabel(event, index) {
    if (event.processing_status === 'processing') return 'Wird bearbeitet';
    if (event.processing_status === 'done') return 'Erledigt';
    if (event.processing_status === 'error') return 'Fehler';
    if (event.processing_status === 'waiting') {
      return index === jobProcessed ? 'An der Reihe' : 'Wartet';
    }
    return 'Wartet';
  }

  function renderEventList() {
    el.eventList.innerHTML = '';
    if (events.length === 0) {
      el.eventList.innerHTML = '<div class="p-4 text-center text-sm text-gray-500">Starte einen Batch, damit hier Events erscheinen.</div>';
      if (el.listCount) el.listCount.textContent = '0';
      return;
    }
    if (el.listCount) el.listCount.textContent = events.length;
    events.forEach((event, index) => {
      const item = document.createElement('div');
      item.id = `event-item-${event.id}`;
      item.className = getEventItemClasses(event);
      item.onclick = () => selectEvent(event.id);
      const position = index + 1;
      const statusLabel = getPipelineStatusLabel(event, index);
      
      item.innerHTML = `
        <span class="status-dot status-dot--${event.processing_status}"></span>
        <span class="flex-shrink-0 text-xs text-gray-500 w-6">${position}.</span>
        <div class="flex-1 min-w-0">
          <span class="block truncate text-sm">${escapeHtml(event.title)}</span>
          <span class="text-xs text-gray-500">${statusLabel}</span>
        </div>
        ${event.result_status ? `<span class="text-xs px-1.5 py-0.5 rounded ${getResultBadgeClass(event.result_status)}">${event.result_status}</span>` : ''}
      `;
      
      el.eventList.appendChild(item);
    });
  }

  function getEventItemClasses(event) {
    let classes = 'event-list-item';
    classes += ` event-list-item--${event.processing_status}`;
    if (event.id === selectedEventId) classes += ' event-list-item--selected';
    if (event.id === jobCurrentEventId) classes += ' event-list-item--current';
    if (isHistoryMode) classes += ' event-list-item--history';
    return classes;
  }

  function updateProgressCurrentBanner() {
    if (!el.progressCurrentBanner || !el.progressCurrentText || !el.progressCurrentTitle) return;
    if (jobTotal > 0 && jobCurrentEventId) {
      const currentEvent = events.find(e => e.id === jobCurrentEventId);
      const title = currentEvent ? currentEvent.title : '(Laden…)';
      el.progressCurrentText.textContent = `Event ${jobProcessed + 1} von ${jobTotal} wird bearbeitet:`;
      el.progressCurrentTitle.textContent = title;
      el.progressCurrentBanner.classList.remove('hidden');
    } else {
      el.progressCurrentBanner.classList.add('hidden');
    }
  }

  function getResultBadgeClass(status) {
    const map = {
      published: 'bg-green-100 text-green-700',
      pending_review: 'bg-amber-100 text-amber-700',
      rejected: 'bg-red-100 text-red-700',
      incomplete: 'bg-gray-100 text-gray-700',
      archived: 'bg-gray-100 text-gray-500',
    };
    return map[status] || 'bg-gray-100 text-gray-700';
  }

  function selectEvent(eventId) {
    selectedEventId = eventId;
    
    // Update list selection
    document.querySelectorAll('.event-list-item').forEach(item => {
      item.classList.remove('event-list-item--selected');
    });
    const selectedItem = document.getElementById(`event-item-${eventId}`);
    if (selectedItem) {
      selectedItem.classList.add('event-list-item--selected');
    }
    
    // Render detail panel with existing data
    renderDetailPanel();
    
    // Lazy-load source details in background
    loadSourceDetails(eventId);
  }

  async function loadSourceDetails(eventId) {
    if (sourceDetailsCache[eventId]) {
      renderSourceDetails(eventId, sourceDetailsCache[eventId]);
      return;
    }
    
    try {
      const res = await fetch(`${API_URL}/api/admin/events/${eventId}/source-details?include=meta,provenance,validation,conflicts,duplicates,ai_runs`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      if (!res.ok) return;
      const { data } = await res.json();
      if (!data) return;
      
      sourceDetailsCache[eventId] = data;
      
      // Only render if still viewing this event
      if (selectedEventId === eventId) {
        renderSourceDetails(eventId, data);
      }
    } catch (e) {
      console.error('Failed to load source details:', e);
    }
  }

  async function loadRawPayload(eventId, sourceId) {
    try {
      const res = await fetch(`${API_URL}/api/admin/events/${eventId}/source-details?include=raw_payload&sourceId=${sourceId}`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      if (!res.ok) return null;
      const { data } = await res.json();
      return data?.sources?.[0] || null;
    } catch (e) {
      console.error('Failed to load raw payload:', e);
      return null;
    }
  }

  function renderDetailPanel() {
    const event = events.find(e => e.id === selectedEventId);
    if (!event) {
      el.detailEmpty.classList.remove('hidden');
      el.detailContent.classList.add('hidden');
      return;
    }

    el.detailEmpty.classList.add('hidden');
    el.detailContent.classList.remove('hidden');

    // Header
    document.getElementById('detail-title').textContent = event.title;
    document.getElementById('copy-event-id').onclick = () => copyToClipboard(event.id);
    
    const sourceLink = document.getElementById('detail-source-link');
    const sourceName = document.getElementById('detail-source-name');
    if (event.source_url) {
      sourceLink.href = event.source_url;
      sourceLink.classList.remove('hidden');
      sourceName.textContent = event.source_name || event.source_url;
    } else {
      sourceLink.classList.add('hidden');
    }

    // Source type badge
    const sourceTypeBadge = document.getElementById('detail-source-type-badge');
    if (event.source_type) {
      sourceTypeBadge.textContent = event.source_type.toUpperCase();
      sourceTypeBadge.classList.remove('hidden');
    } else {
      sourceTypeBadge.classList.add('hidden');
    }

    // Status badge
    const statusBadge = document.getElementById('detail-status-badge');
    statusBadge.textContent = event.processing_status;
    statusBadge.className = `flex-shrink-0 px-3 py-1 rounded-full text-sm font-medium ${getStatusBadgeClass(event.processing_status)}`;

    // Suggested actions
    renderSuggestedActions(event);

    // Daten fuer AI-Worker (Eingabedaten-Uebersicht)
    renderInputDataOverview(event);
    
    // Validation checks  
    renderValidationChecks(event);

    // Missing fields
    const missingSection = document.getElementById('detail-missing');
    if (event.missing_fields && event.missing_fields.length > 0) {
      missingSection.classList.remove('hidden');
      document.getElementById('detail-missing-list').textContent = event.missing_fields.join(', ');
    } else {
      missingSection.classList.add('hidden');
    }

    // Smart crawl UI
    renderCrawlSection(event);

    // All fields (grouped)
    renderAllFields(event);
    
    // AI fields
    renderAIFields(event);
    
    // Scores
    renderScores(event);
    
    // Meta
    renderMeta(event);
    
    // Error
    renderError(event);
  }

  function getStatusBadgeClass(status) {
    const map = {
      waiting: 'bg-gray-100 text-gray-600',
      processing: 'bg-amber-100 text-amber-700',
      done: 'bg-green-100 text-green-700',
      error: 'bg-red-100 text-red-700',
    };
    return map[status] || 'bg-gray-100 text-gray-600';
  }

  function renderAllFields(event) {
    const existing = event.existing || {};
    const diff = event.diff || {};
    const provenance = existing.field_provenance || {};

    // Helper to render a field group into a container
    function renderFieldGroup(containerId, fields) {
      const container = document.getElementById(containerId);
      if (!container) return;
      container.innerHTML = fields.map(f => renderSingleField(f, existing, diff, provenance)).join('');
    }

    // Basis
    renderFieldGroup('fields-basic', [
      { key: 'title', label: 'Titel' },
      { key: 'description_short', label: 'Kurzbeschreibung', wide: true },
    ]);

    // Datum/Zeit
    renderFieldGroup('fields-datetime', [
      { key: 'start_datetime', label: 'Start', format: v => v ? formatDateTime(v) : null },
      { key: 'end_datetime', label: 'Ende', format: v => v ? formatDateTime(v) : null },
      { key: 'is_all_day', label: 'Ganztaegig', format: v => v ? 'Ja' : 'Nein' },
      { key: 'recurrence_rule', label: 'Wiederholung' },
    ]);

    // Ort
    renderFieldGroup('fields-location', [
      { key: 'venue_name', label: 'Venue' },
      { key: 'location_address', label: 'Adresse' },
      { key: 'city', label: 'Stadt' },
      { key: 'postal_code', label: 'PLZ' },
      { key: 'location_district', label: 'Stadtteil' },
      { key: 'country_code', label: 'Land' },
    ]);

    // Preis
    renderFieldGroup('fields-price', [
      { key: 'price_type', label: 'Preistyp' },
      { key: 'price_min', label: 'Preis Min', format: v => v !== null && v !== undefined ? `${v} EUR` : null },
      { key: 'price_max', label: 'Preis Max', format: v => v !== null && v !== undefined ? `${v} EUR` : null },
      { key: 'price_details', label: 'Preis-Details', format: v => v && typeof v === 'object' ? JSON.stringify(v) : v },
    ]);

    // Zielgruppe
    renderFieldGroup('fields-audience', [
      { key: 'age_min', label: 'Alter Min', format: v => v !== null ? `${v}+` : null },
      { key: 'age_max', label: 'Alter Max', format: v => v !== null ? `bis ${v}` : null },
      { key: 'age_rating', label: 'Altersfreigabe' },
    ]);

    // Details
    renderFieldGroup('fields-details', [
      { key: 'is_indoor', label: 'Indoor', format: v => v ? 'Ja' : 'Nein' },
      { key: 'is_outdoor', label: 'Outdoor', format: v => v ? 'Ja' : 'Nein' },
      { key: 'booking_url', label: 'Buchungs-URL', format: v => v ? `<a href="${escapeHtml(v)}" target="_blank" class="text-primary-600 hover:underline truncate block text-xs">${escapeHtml(v)}</a>` : null, html: true },
      { key: 'image_urls', label: 'Bilder', format: v => Array.isArray(v) && v.length > 0 ? `${v.length} Bild(er)` : null },
      { key: 'availability_status', label: 'Verfuegbarkeit' },
      { key: 'ai_summary_short', label: 'AI Zusammenfassung' },
    ]);
  }

  function renderSingleField(f, existing, diff, provenance) {
    const existingVal = existing[f.key];
    const diffEntry = diff[f.key];
    const prov = provenance[f.key];
    const displayVal = f.format ? f.format(existingVal) : existingVal;
    
    let cardClass = 'field-card';
    let valueHtml = '';
    let badges = '';
    
    // Source badge
    if (prov) {
      const src = typeof prov === 'string' ? prov : prov.source;
      badges += getSourceBadge(src);
      if (prov.confidence) {
        badges += `<span class="text-xs text-gray-400 ml-1">${Math.round(prov.confidence * 100)}%</span>`;
      }
    }
    
    if (diffEntry) {
      if (diffEntry.type === 'added') {
        cardClass += ' field-card--added';
        const newVal = f.format ? f.format(diffEntry.new_value) : diffEntry.new_value;
        valueHtml = `<span class="text-green-700">${f.html ? (newVal || '--') : escapeHtml(String(newVal || '--'))}</span>`;
        badges += '<span class="ai-badge">AI</span>';
      } else if (diffEntry.type === 'changed') {
        cardClass += ' field-card--changed';
        const oldVal = f.format ? f.format(diffEntry.old_value) : diffEntry.old_value;
        const newVal = f.format ? f.format(diffEntry.new_value) : diffEntry.new_value;
        valueHtml = `<span class="text-gray-400 line-through">${escapeHtml(String(oldVal || '--'))}</span> <span class="text-green-700 font-medium">${escapeHtml(String(newVal || '--'))}</span>`;
        badges += '<span class="ai-badge">AI</span>';
      } else {
        valueHtml = displayVal === null || displayVal === undefined || displayVal === '' 
          ? '<span class="text-gray-400">--</span>'
          : (f.html ? String(displayVal) : `<span class="text-gray-900">${escapeHtml(String(displayVal))}</span>`);
      }
    } else if (displayVal === null || displayVal === undefined || displayVal === '') {
      cardClass += ' field-card--empty';
      valueHtml = '<span class="text-gray-400">--leer--</span>';
    } else {
      valueHtml = f.html ? String(displayVal) : `<span class="text-gray-900">${escapeHtml(String(displayVal))}</span>`;
    }
    
    const colSpan = f.wide ? ' col-span-2' : '';
    
    return `
      <div class="${cardClass}${colSpan}">
        <p class="text-xs text-gray-500 mb-1">${f.label}${badges}</p>
        <p class="text-sm font-medium">${valueHtml}</p>
      </div>
    `;
  }

  function getSourceBadge(source) {
    const map = {
      feed: { cls: 'source-badge--feed', label: 'Feed' },
      rss: { cls: 'source-badge--feed', label: 'RSS' },
      ical: { cls: 'source-badge--feed', label: 'iCal' },
      crawl: { cls: 'source-badge--crawl', label: 'Crawl' },
      ai: { cls: 'source-badge--ai', label: 'AI' },
      ai_classify: { cls: 'source-badge--ai', label: 'AI' },
      manual: { cls: 'source-badge--manual', label: 'Manuell' },
      manual_override: { cls: 'source-badge--manual', label: 'Manuell' },
    };
    const m = map[source] || { cls: 'source-badge--unknown', label: source || '?' };
    return `<span class="source-badge ${m.cls}">${m.label}</span>`;
  }

  function renderAIFields(event) {
    const container = document.getElementById('fields-ai');
    const section = document.getElementById('section-ai');
    const proposed = event.proposed;
    
    if (!proposed) {
      section.classList.add('hidden');
      return;
    }
    
    section.classList.remove('hidden');
    
    const fields = [
      { key: 'categories', label: 'Kategorien', format: v => Array.isArray(v) ? v.join(', ') : v },
      { key: 'age_rating', label: 'Altersfreigabe' },
      { key: 'ai_summary_short', label: 'AI Zusammenfassung' },
      { key: 'ai_fit_blurb', label: 'Familien-Fit' },
    ];
    
    container.innerHTML = fields.map(f => {
      const val = proposed[f.key];
      const displayVal = f.format ? f.format(val) : val;
      
      if (!displayVal) return '';
      
      return `
        <div class="field-card field-card--added col-span-2">
          <p class="text-xs text-gray-500 mb-1">${f.label}<span class="ai-badge">AI</span></p>
          <p class="text-sm text-green-700">${escapeHtml(String(displayVal))}</p>
        </div>
      `;
    }).join('');
  }

  function renderScores(event) {
    const container = document.getElementById('fields-scores');
    const section = document.getElementById('section-scores');
    const proposed = event.proposed;
    
    if (!proposed || proposed.family_fit_score === null) {
      section.classList.add('hidden');
      return;
    }
    
    section.classList.remove('hidden');
    
    const scores = [
      { key: 'family_fit_score', label: 'Family Fit' },
      { key: 'relevance_score', label: 'Relevanz' },
      { key: 'quality_score', label: 'Qualitaet' },
      { key: 'stressfree_score', label: 'Stressfrei' },
    ];
    
    container.innerHTML = scores.map(s => {
      const val = proposed[s.key];
      if (val === null || val === undefined) return '';
      
      const colorClass = val >= 70 ? 'high' : val >= 40 ? 'medium' : 'low';
      
      return `
        <div class="field-card">
          <div class="flex justify-between items-center mb-2">
            <span class="text-xs text-gray-500">${s.label}</span>
            <span class="text-sm font-bold">${val}</span>
          </div>
          <div class="score-bar-container">
            <div class="score-bar-fill score-bar-fill--${colorClass}" style="width: ${val}%"></div>
          </div>
        </div>
      `;
    }).join('');
  }

  function renderMeta(event) {
    const container = document.getElementById('fields-meta');
    const section = document.getElementById('section-meta');
    const meta = event.meta;
    
    if (!meta) {
      section.classList.add('hidden');
      return;
    }
    
    section.classList.remove('hidden');
    
    container.innerHTML = `
      <div class="field-card">
        <p class="text-xs text-gray-500">Model</p>
        <p class="text-sm font-medium">${escapeHtml(meta.model || '--')}</p>
      </div>
      <div class="field-card">
        <p class="text-xs text-gray-500">Konfidenz</p>
        <p class="text-sm font-medium">${meta.confidence ? (meta.confidence * 100).toFixed(0) + '%' : '--'}</p>
      </div>
      <div class="field-card">
        <p class="text-xs text-gray-500">Kosten</p>
        <p class="text-sm font-medium">${meta.cost_usd ? '$' + meta.cost_usd.toFixed(4) : '--'}</p>
      </div>
      <div class="field-card">
        <p class="text-xs text-gray-500">Zeit</p>
        <p class="text-sm font-medium">${meta.processing_time_ms ? meta.processing_time_ms + 'ms' : '--'}</p>
      </div>
    `;
  }

  function renderError(event) {
    const section = document.getElementById('section-error');
    const error = event.error;
    
    if (!error) {
      section.classList.add('hidden');
      return;
    }
    
    section.classList.remove('hidden');
    const msg = error.message || 'Unbekannter Fehler';
    const isQuota = error.type === 'ai_fallback' || /Kontingent|quota|429|insufficient_quota/i.test(msg);
    document.getElementById('error-message').textContent = isQuota
      ? 'OpenAI-Kontingent erschöpft – die API lehnt Anfragen ab (nicht unser App-Budget).'
      : msg;
    document.getElementById('error-step').textContent = `Schritt: ${error.step || 'unbekannt'} | ${error.retryable ? 'Wiederholbar' : 'Nicht wiederholbar'}`;
    const hintEl = document.getElementById('error-hint');
    if (isQuota && hintEl) {
      hintEl.textContent = '→ Unter platform.openai.com einloggen → Billing → Zahlungsmethode hinzufügen bzw. Nutzungslimit anheben. Danach Batch erneut starten.';
      hintEl.classList.remove('hidden');
    } else if (hintEl) {
      hintEl.classList.add('hidden');
    }
  }

  // ========================================
  // NEW RENDERING FUNCTIONS
  // ========================================

  function renderSuggestedActions(event) {
    const section = document.getElementById('section-actions');
    const list = document.getElementById('actions-list');
    const actions = event.suggested_actions || [];
    
    if (actions.length === 0) {
      section.classList.add('hidden');
      return;
    }
    section.classList.remove('hidden');
    list.innerHTML = actions.map(a => 
      `<button class="action-btn" data-action="${a.action_type}" data-field="${a.field || ''}" title="${escapeHtml(a.description)}">
        ${a.action_type === 'crawl' ? '&#x1F310;' : a.action_type === 'ai_rerun' ? '&#x1F916;' : '&#x270F;'} ${escapeHtml(a.label)}
      </button>`
    ).join('');
    
    // Bind action buttons
    list.querySelectorAll('.action-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const actionType = btn.getAttribute('data-action');
        if (actionType === 'crawl') {
          document.getElementById('crawl-btn')?.click();
        } else if (actionType === 'ai_rerun') {
          document.getElementById('detail-trigger-ai')?.click();
        }
      });
    });
  }

  const INPUT_DATA_OVERVIEW_FIELDS = [
    { key: 'title', label: 'Titel' },
    { key: 'location_address', label: 'Adresse' },
    { key: 'venue_name', label: 'Venue' },
    { key: 'city', label: 'Stadt' },
    { key: 'postal_code', label: 'PLZ' },
    { key: 'start_datetime', label: 'Start', format: v => v ? formatDateTime(v) : null },
    { key: 'end_datetime', label: 'Ende', format: v => v ? formatDateTime(v) : null },
    { key: 'price_type', label: 'Preistyp' },
    { key: 'price_min', label: 'Preis Min', format: v => v != null ? `${v}€` : null },
    { key: 'price_max', label: 'Preis Max', format: v => v != null ? `${v}€` : null },
    { key: 'is_indoor', label: 'Indoor', format: v => v ? 'Ja' : null },
    { key: 'is_outdoor', label: 'Outdoor', format: v => v ? 'Ja' : null },
    { key: 'description_short', label: 'Kurzbeschreibung', format: v => (v && v.length > 120 ? v.slice(0, 120) + '…' : v) || null },
    { key: 'description_long', label: 'Beschreibung', format: v => (v && v.length > 120 ? v.slice(0, 120) + '…' : v) || null },
  ];

  const PROVENANCE_FEED = ['feed', 'rss', 'ical', 'normalizer'];
  const PROVENANCE_CRAWL = ['crawl'];
  const PROVENANCE_AI = ['ai', 'ai_classify'];
  const PROVENANCE_MANUAL = ['manual', 'manual_override'];

  function renderInputDataOverview(event) {
    const existing = event.existing || {};
    const provenance = existing.field_provenance || {};
    const desc = existing.description_long || existing.description_short || '';
    const descSnippet = desc ? (desc.length > 250 ? desc.slice(0, 250) + '…' : desc) : '--';
    document.getElementById('input-data-title').textContent = existing.title || '--';
    document.getElementById('input-data-address').textContent = existing.location_address || '--';
    document.getElementById('input-data-start').textContent = existing.start_datetime ? formatDateTime(existing.start_datetime) : '--';
    document.getElementById('input-data-end').textContent = existing.end_datetime ? formatDateTime(existing.end_datetime) : '--';
    const priceStr = existing.price_min != null || existing.price_max != null
      ? [existing.price_min != null ? `${existing.price_min}€` : '', existing.price_max != null ? `${existing.price_max}€` : ''].filter(Boolean).join(' – ') || (existing.price_type === 'free' ? 'Kostenlos' : '--')
      : (existing.price_type === 'free' ? 'Kostenlos' : '--');
    document.getElementById('input-data-price').textContent = priceStr;
    const io = [];
    if (existing.is_indoor) io.push('Indoor');
    if (existing.is_outdoor) io.push('Outdoor');
    document.getElementById('input-data-indoor-outdoor').textContent = io.length ? io.join(', ') : '--';
    document.getElementById('input-data-description').textContent = descSnippet;

    // Daten nach Herkunft gruppieren
    function getDisplayValue(f, obj) {
      const raw = obj[f.key];
      if (raw === null || raw === undefined || raw === '') return null;
      if (Array.isArray(raw) && raw.length === 0) return null;
      return f.format ? f.format(raw) : String(raw);
    }
    function inGroup(prov) {
      const s = (typeof prov === 'string' ? prov : (prov && typeof prov === 'object' && 'source' in prov ? prov.source : '')) || '';
      const src = String(s).toLowerCase();
      if (PROVENANCE_FEED.includes(src)) return 'feed';
      if (PROVENANCE_CRAWL.includes(src)) return 'crawl';
      if (PROVENANCE_AI.includes(src)) return 'ai';
      if (PROVENANCE_MANUAL.includes(src)) return 'manual';
      return null;
    }
    const bySource = { feed: [], crawl: [], ai: [], manual: [] };
    const hasProvenance = Object.keys(provenance).length > 0;
    for (const f of INPUT_DATA_OVERVIEW_FIELDS) {
      const val = getDisplayValue(f, existing);
      if (val == null) continue;
      const prov = provenance[f.key];
      const src = hasProvenance && prov != null ? inGroup(prov) : 'feed';
      const bucket = (src && bySource[src]) ? src : 'feed';
      bySource[bucket].push({ label: f.label, value: val });
    }
    function renderBucket(containerId, fieldsId, items) {
      const section = document.getElementById(containerId);
      const fieldsEl = document.getElementById(fieldsId);
      if (!section || !fieldsEl) return;
      if (items.length === 0) {
        section.classList.add('hidden');
        return;
      }
      section.classList.remove('hidden');
      fieldsEl.innerHTML = items.map(it =>
        `<div><span class="text-slate-500">${escapeHtml(it.label)}:</span></div><div class="truncate">${escapeHtml(it.value)}</div>`
      ).join('');
    }
    renderBucket('input-data-from-feed', 'input-data-from-feed-fields', bySource.feed);
    renderBucket('input-data-from-crawl', 'input-data-from-crawl-fields', bySource.crawl);
    renderBucket('input-data-from-ai', 'input-data-from-ai-fields', bySource.ai);
    renderBucket('input-data-from-manual', 'input-data-from-manual-fields', bySource.manual);
  }

  function renderValidationChecks(event) {
    const section = document.getElementById('section-checks');
    const summary = document.getElementById('checks-summary');
    const list = document.getElementById('checks-list');
    const checks = event.validation_checks || [];
    
    if (checks.length === 0 || (checks.length === 1 && checks[0].status === 'pass')) {
      if (checks.length === 1 && checks[0].status === 'pass') {
        section.classList.remove('hidden');
        summary.textContent = 'Alle OK';
        summary.className = 'text-xs px-2 py-0.5 rounded-full bg-green-100 text-green-700';
        list.classList.add('hidden');
      } else {
        section.classList.add('hidden');
      }
      return;
    }
    
    section.classList.remove('hidden');
    const fails = checks.filter(c => c.status === 'fail').length;
    const warns = checks.filter(c => c.status === 'warn').length;
    
    if (fails > 0) {
      summary.textContent = `${fails} Fehler, ${warns} Warnungen`;
      summary.className = 'text-xs px-2 py-0.5 rounded-full bg-red-100 text-red-700';
    } else {
      summary.textContent = `${warns} Warnungen`;
      summary.className = 'text-xs px-2 py-0.5 rounded-full bg-amber-100 text-amber-700';
    }
    
    list.classList.remove('hidden');
    list.innerHTML = checks.filter(c => c.status !== 'pass').map(c => 
      `<div class="flex items-center gap-2 text-xs">
        <span class="check-dot check-dot--${c.status}"></span>
        <span class="font-medium">${escapeHtml(c.label)}</span>
        <span class="text-gray-400">${escapeHtml(c.message)}</span>
      </div>`
    ).join('');
  }

  function renderCrawlSection(event) {
    const section = document.getElementById('section-crawl');
    const urlDisplay = document.getElementById('crawl-url-display');
    const urlLink = document.getElementById('crawl-url-link');
    const copyBtn = document.getElementById('copy-crawl-url');
    const statusBadge = document.getElementById('crawl-status-badge');
    const crawlBtn = document.getElementById('crawl-btn');
    const crawlUrl = event.crawl_url || event.source_url;
    
    section.classList.remove('hidden');
    
    if (crawlUrl) {
      urlLink.href = crawlUrl;
      urlLink.textContent = crawlUrl;
      urlDisplay.classList.remove('hidden');
      copyBtn.onclick = () => copyToClipboard(crawlUrl);
      crawlBtn.disabled = false;
    } else {
      urlDisplay.classList.add('hidden');
      crawlBtn.disabled = true;
      crawlBtn.textContent = 'Keine URL vorhanden';
    }
    
    // Crawl status
    if (event.has_been_crawled) {
      statusBadge.textContent = 'Bereits gecrawlt';
      statusBadge.className = 'text-xs px-2 py-0.5 rounded-full bg-green-100 text-green-700';
    } else if (crawlUrl) {
      statusBadge.textContent = 'Noch nicht gecrawlt';
      statusBadge.className = 'text-xs px-2 py-0.5 rounded-full bg-gray-100 text-gray-600';
    } else {
      statusBadge.textContent = 'Keine URL';
      statusBadge.className = 'text-xs px-2 py-0.5 rounded-full bg-red-100 text-red-600';
    }

    // Hide diagnostics by default
    document.getElementById('crawl-diagnostics').classList.add('hidden');
    document.getElementById('crawl-result').classList.add('hidden');
    document.getElementById('crawl-raw-details').classList.add('hidden');
  }

  function renderSourceDetails(eventId, data) {
    // Sources timeline
    renderSourceTimeline(data.sources || []);
    
    // Field conflicts
    renderFieldConflicts(data.field_conflicts || {});
    
    // AI run history
    renderAIRunHistory(data.ai_runs || []);
    
    // Duplicate candidates
    renderDuplicateCandidates(data.duplicate_candidates || []);
    
    // Update field provenance from fresh data
    const event = events.find(e => e.id === eventId);
    if (event && data.field_provenance) {
      if (!event.existing) event.existing = {};
      event.existing.field_provenance = data.field_provenance;
      event.existing.field_fill_status = data.field_fill_status || {};
      renderAllFields(event);
    }
  }

  function renderSourceTimeline(sources) {
    const section = document.getElementById('section-sources');
    const timeline = document.getElementById('sources-timeline');
    const countEl = document.getElementById('sources-count');
    
    if (!sources || sources.length === 0) {
      section.classList.add('hidden');
      return;
    }
    
    section.classList.remove('hidden');
    countEl.textContent = sources.length;
    
    timeline.innerHTML = sources.map((src, idx) => `
      <div class="source-card" id="source-card-${idx}">
        <div class="source-card-header" onclick="toggleSourceCard(${idx})">
          <div class="flex items-center gap-2">
            ${getSourceBadge(src.source_type)}
            <span class="text-sm font-medium">${escapeHtml(src.source_name)}</span>
            <span class="text-xs text-gray-400">${src.field_count} Felder</span>
          </div>
          <div class="flex items-center gap-2">
            <span class="text-xs text-gray-400">${formatDateTime(src.fetched_at)}</span>
            ${src.source_url ? `<a href="${escapeHtml(src.source_url)}" target="_blank" class="text-xs text-primary-600 hover:underline" onclick="event.stopPropagation()">&#x1F517;</a>` : ''}
            <span class="text-xs text-gray-400">&#x25BC;</span>
          </div>
        </div>
        <div class="source-card-body" id="source-body-${idx}">
          <div class="mb-2">
            <p class="text-xs text-gray-500 mb-1">Extrahierte Felder:</p>
            <p class="text-xs text-gray-700">${src.fields_preview?.join(', ') || 'keine'}</p>
          </div>
          <div id="source-raw-${idx}" class="mt-2">
            ${src.raw_payload ? renderJsonTree(src.raw_payload, 'Raw Payload') : ''}
            ${src.extracted_fields ? renderJsonTree(src.extracted_fields, 'Extracted Fields') : ''}
            ${src.normalized_data ? renderJsonTree(src.normalized_data, 'Normalized Data') : ''}
            ${!src.raw_payload && !src.extracted_fields && !src.normalized_data ? `<button class="action-btn" onclick="loadAndShowRawPayload('${selectedEventId}', '${src.id}', ${idx})">Raw-Daten laden</button>` : ''}
          </div>
        </div>
      </div>
    `).join('');
  }

  function renderJsonTree(data, label) {
    if (!data || typeof data !== 'object') return '';
    const json = JSON.stringify(data, null, 2);
    const truncated = json.length > 2000 ? json.substring(0, 2000) + '\n...' : json;
    return `
      <details class="mt-1">
        <summary class="text-xs text-gray-500 cursor-pointer hover:text-gray-700">${escapeHtml(label)} (${Object.keys(data).length} keys)</summary>
        <pre class="json-tree mt-1 p-2 bg-white border border-gray-200 rounded overflow-x-auto max-h-60 overflow-y-auto">${syntaxHighlightJson(truncated)}</pre>
      </details>
    `;
  }

  function syntaxHighlightJson(json) {
    return escapeHtml(json)
      .replace(/"([^"]+)":/g, '<span class="json-key">"$1"</span>:')
      .replace(/: "([^"]*?)"/g, ': <span class="json-string">"$1"</span>')
      .replace(/: (\d+\.?\d*)/g, ': <span class="json-number">$1</span>')
      .replace(/: (null)/g, ': <span class="json-null">null</span>')
      .replace(/: (true|false)/g, ': <span class="json-bool">$1</span>');
  }

  function renderFieldConflicts(conflicts) {
    const section = document.getElementById('section-conflicts');
    const list = document.getElementById('conflicts-list');
    const countEl = document.getElementById('conflicts-count');
    const keys = Object.keys(conflicts);
    
    if (keys.length === 0) {
      section.classList.add('hidden');
      return;
    }
    
    section.classList.remove('hidden');
    countEl.textContent = keys.length;
    
    list.innerHTML = keys.map(field => {
      const conflict = conflicts[field];
      return `
        <div class="conflict-item">
          <div class="flex items-center justify-between mb-1">
            <span class="text-sm font-medium">${escapeHtml(field)}</span>
            <span class="text-xs text-orange-600">${conflict.values.length} Quellen</span>
          </div>
          ${conflict.values.map(v => `
            <div class="flex items-center justify-between mt-1 text-xs">
              <div class="flex items-center gap-2">
                ${getSourceBadge(v.source_type)}
                <span class="text-gray-700">${escapeHtml(String(v.value).substring(0, 80))}</span>
              </div>
              <button class="action-btn text-xs py-0.5 px-2" onclick="applyOverride('${selectedEventId}', '${escapeHtml(field)}', ${JSON.stringify(v.value).replace(/'/g, "\\'")})" title="Diesen Wert uebernehmen">Uebernehmen</button>
            </div>
          `).join('')}
        </div>
      `;
    }).join('');
  }

  function renderAIRunHistory(runs) {
    const section = document.getElementById('section-ai-history');
    const list = document.getElementById('ai-history-list');
    const countEl = document.getElementById('ai-history-count');
    
    if (!runs || runs.length === 0) {
      section.classList.add('hidden');
      return;
    }
    
    section.classList.remove('hidden');
    countEl.textContent = runs.length;
    
    list.innerHTML = runs.map(run => `
      <div class="p-2 bg-gray-50 rounded text-xs space-y-1">
        <div class="flex items-center justify-between">
          <span class="font-medium">${escapeHtml(run.model)} (${escapeHtml(run.prompt_version)})</span>
          <span class="text-gray-400">${formatDateTime(run.timestamp)}</span>
        </div>
        <div class="flex items-center gap-3 text-gray-500">
          <span>Trigger: ${run.triggered_by}</span>
          ${run.cost_usd ? `<span>Kosten: $${run.cost_usd.toFixed(4)}</span>` : ''}
          ${run.processing_time_ms ? `<span>Zeit: ${run.processing_time_ms}ms</span>` : ''}
          ${run.input_hash ? `<span class="font-mono text-gray-300" title="Input Hash">#${run.input_hash.substring(0, 8)}</span>` : ''}
        </div>
      </div>
    `).join('');
  }

  function renderDuplicateCandidates(candidates) {
    const section = document.getElementById('section-duplicates');
    const list = document.getElementById('duplicates-list');
    const countEl = document.getElementById('duplicates-count');
    
    if (!candidates || candidates.length === 0) {
      section.classList.add('hidden');
      return;
    }
    
    section.classList.remove('hidden');
    countEl.textContent = candidates.length;
    
    list.innerHTML = candidates.map(dup => {
      const scoreColor = dup.matching_score >= 0.8 ? 'text-green-600' : dup.matching_score >= 0.5 ? 'text-amber-600' : 'text-red-600';
      return `
        <div class="p-2 border border-gray-200 rounded text-xs">
          <div class="flex items-center justify-between mb-1">
            <span class="font-medium">${escapeHtml(dup.event_title)}</span>
            <span class="${scoreColor} font-bold">${(dup.matching_score * 100).toFixed(0)}%</span>
          </div>
          <div class="flex items-center gap-3 text-gray-500">
            ${dup.event_date ? `<span>${formatDateTime(dup.event_date)}</span>` : ''}
            ${dup.event_location ? `<span>${escapeHtml(dup.event_location.substring(0, 40))}</span>` : ''}
          </div>
          ${dup.resolution ? `<span class="text-xs text-gray-400">Status: ${dup.resolution}</span>` : `
            <div class="mt-1 flex gap-2">
              <button class="action-btn text-xs py-0.5">Nicht gleich</button>
            </div>
          `}
        </div>
      `;
    }).join('');
  }

  // ========================================
  // UTILITY FUNCTIONS
  // ========================================

  function copyToClipboard(text) {
    navigator.clipboard.writeText(text).then(() => {
      // Brief visual feedback (could be improved with a toast)
    }).catch(() => {
      // Fallback
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
    });
  }

  async function applyOverride(eventId, field, value) {
    const reason = prompt('Begruendung (optional):');
    try {
      const res = await fetch(`${API_URL}/api/admin/events/${eventId}/fields`, {
        method: 'PATCH',
        headers: { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({ field, value, reason: reason || null }),
      });
      const data = await res.json();
      if (data.success) {
        // Clear cache and reload
        delete sourceDetailsCache[eventId];
        loadSourceDetails(eventId);
      } else {
        alert('Fehler: ' + (data.error || 'Unknown'));
      }
    } catch (e) {
      alert('Netzwerkfehler: ' + e.message);
    }
  }

  // Global functions for onclick handlers
  window.toggleSourceCard = function(idx) {
    const body = document.getElementById(`source-body-${idx}`);
    if (body) body.classList.toggle('open');
  };

  window.loadAndShowRawPayload = async function(eventId, sourceId, idx) {
    const container = document.getElementById(`source-raw-${idx}`);
    if (!container) return;
    container.innerHTML = '<span class="text-xs text-gray-400">Laden...</span>';
    const data = await loadRawPayload(eventId, sourceId);
    if (data) {
      let html = '';
      if (data.raw_payload) html += renderJsonTree(data.raw_payload, 'Raw Payload');
      if (data.extracted_fields) html += renderJsonTree(data.extracted_fields, 'Extracted Fields');
      if (data.normalized_data) html += renderJsonTree(data.normalized_data, 'Normalized Data');
      container.innerHTML = html || '<span class="text-xs text-gray-400">Keine Rohdaten vorhanden</span>';
    } else {
      container.innerHTML = '<span class="text-xs text-red-400">Fehler beim Laden</span>';
    }
  };

  function formatDateTime(isoString) {
    if (!isoString) return null;
    const d = new Date(isoString);
    return d.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit', year: '2-digit', hour: '2-digit', minute: '2-digit' });
  }

  function escapeHtml(str) {
    if (!str) return '';
    return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
  }

  // ========================================
  // POLLING
  // ========================================
  function startPolling() {
    pollJobStatus();
  }

  function stopPolling() {
    if (pollTimeout) {
      clearTimeout(pollTimeout);
      pollTimeout = null;
    }
  }

  async function pollJobStatus() {
    if (!currentJobId) return;

    try {
      const url = lastChangedAt 
        ? `${API_URL}/api/admin/ai-job-status/${currentJobId}?changed_since=${encodeURIComponent(lastChangedAt)}`
        : `${API_URL}/api/admin/ai-job-status/${currentJobId}`;
      
      const res = await fetch(url, {
        headers: { Authorization: `Bearer ${token}` }
      });

      if (res.status === 503) {
        poll503Count++;
        if (poll503Count >= POLL_503_MAX) {
          stopPolling();
          showRedisUnavailableBanner();
          return;
        }
        schedulePoll();
        return;
      }

      if (!res.ok) {
        console.error('Failed to poll job status');
        schedulePoll();
        return;
      }

      poll503Count = 0;
      const { data } = await res.json();
      if (!data) {
        schedulePoll();
        return;
      }

      // Check if there are changes
      if (data.last_updated_at !== lastChangedAt) {
        pollInterval = POLL_MIN_INTERVAL;
        lastChangedAt = data.last_updated_at;
        updateFromJobStatus(data);
      } else {
        pollInterval = Math.min(pollInterval * 1.5, POLL_MAX_INTERVAL);
      }

      if (data.status === 'completed' || data.status === 'failed') {
        // Final fetch to get all data
        const finalRes = await fetch(`${API_URL}/api/admin/ai-job-status/${currentJobId}`, {
          headers: { Authorization: `Bearer ${token}` }
        });
        if (finalRes.ok) {
          const { data: finalData } = await finalRes.json();
          updateFromJobStatus(finalData);
        }
        onJobComplete(data);
        return;
      }

      schedulePoll();

    } catch (e) {
      console.error('Polling error:', e);
      schedulePoll();
    }
  }

  function schedulePoll() {
    pollTimeout = setTimeout(pollJobStatus, pollInterval);
  }

  function showRedisUnavailableBanner() {
    const banner = document.getElementById('redis-unavailable-banner');
    if (banner) banner.classList.remove('hidden');
  }

  function updateFromJobStatus(data) {
    jobProcessed = data.processed ?? jobProcessed;
    jobTotal = data.total ?? jobTotal;
    jobCurrentEventId = data.current_event_id ?? data.currentEventId ?? jobCurrentEventId;

    // Update progress
    const percent = data.total > 0 ? Math.round((data.processed / data.total) * 100) : 0;
    el.progressBar.style.width = `${percent}%`;
    el.progressText.textContent = `${data.processed} / ${data.total}`;
    el.progressPercent.textContent = `${percent}%`;

    updateProgressCurrentBanner();

    // Update summary
    if (data.summary) {
      el.statPublished.textContent = data.summary.published || 0;
      el.statReview.textContent = data.summary.pending_review || 0;
      el.statFailed.textContent = data.summary.failed || 0;
    }

    // Update cost
    if (data.total_cost_usd > 0) {
      el.costBadge.classList.remove('hidden');
      el.totalCost.textContent = '$' + data.total_cost_usd.toFixed(3);
    }

    // Update heartbeat indicator (vertrauenswuerdiger Status)
    if (data.heartbeat_status !== undefined && data.heartbeat_age_seconds !== undefined) {
      updateHeartbeatIndicator(data.heartbeat_status, data.heartbeat_age_seconds);
    }

    // Handle stale status from server
    if (data.status === 'stale') {
      updateHeartbeatIndicator('critical', data.heartbeat_age_seconds || 300);
    }

    // Merge event updates
    if (data.events && data.events.length > 0) {
      data.events.forEach(updatedEvent => {
        const idx = events.findIndex(e => e.id === updatedEvent.id);
        if (idx !== -1) {
          events[idx] = { ...events[idx], ...updatedEvent };
        }
      });
      
      // Auto-select current processing event
      if (data.currentEventId && data.currentEventId !== selectedEventId) {
        selectEvent(data.currentEventId);
        scrollEventIntoView(data.currentEventId);
      } else if (selectedEventId) {
        renderDetailPanel();
      }
    }
    // Always refresh list so pipeline labels and current row reflect jobProcessed/jobCurrentEventId
    if (events.length > 0) renderEventList();
  }

  function scrollEventIntoView(eventId) {
    const item = document.getElementById(`event-item-${eventId}`);
    if (item) {
      item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
  }

  // ========================================
  // ELAPSED TIMER
  // ========================================
  function startElapsedTimer() {
    if (elapsedInterval) clearInterval(elapsedInterval);
    elapsedInterval = setInterval(updateElapsedTime, 1000);
  }

  function stopElapsedTimer() {
    if (elapsedInterval) {
      clearInterval(elapsedInterval);
      elapsedInterval = null;
    }
  }

  function updateElapsedTime() {
    if (!startTime) return;
    const elapsed = Math.floor((Date.now() - startTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    el.elapsedTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
  }

  // ========================================
  // JOB COMPLETION
  // ========================================
  async function onJobComplete(data) {
    stopPolling();
    stopElapsedTimer();
    isHistoryMode = true;
    try { sessionStorage.removeItem(AI_WORKER_JOB_KEY); } catch (e) { /* ignore */ }
    
    // Refetch job so event list has final proposed/diff for "Alle Felder" view.
    // Kurze Verzoegerung, damit Backend die letzten Event-Updates in Redis geschrieben hat.
    function doRefetch() {
      if (!currentJobId || !token) return;
      fetch(`${API_URL}/api/admin/ai-job-status/${currentJobId}`, { headers: { Authorization: `Bearer ${token}` } })
        .then(res => res.ok ? res.json() : null)
        .then(json => {
          const jobData = json?.data;
          if (jobData?.events?.length) {
            events = jobData.events;
            renderEventList();
            if (selectedEventId) {
              renderDetailPanel();
            }
          }
        })
        .catch(() => {});
    }
    setTimeout(doRefetch, 400);
    // Falls Redis kurz verzögert: zweiter Versuch
    setTimeout(doRefetch, 1200);
    
    renderEventList();
    
    setTimeout(() => {
      el.progressSection.classList.add('hidden');
    }, 2000);
    
    resetButton();
    reloadPendingCount();
  }

  async function cancelProcessing() {
    if (currentJobId) {
      try {
        await fetch(`${API_URL}/api/admin/ai-jobs/${currentJobId}/cancel`, {
          method: 'POST',
          headers: { Authorization: `Bearer ${token}` }
        });
      } catch (e) {
        console.error('Cancel job request failed:', e);
      }
      currentJobId = null;
    }
    stopPolling();
    stopElapsedTimer();
    try { sessionStorage.removeItem(AI_WORKER_JOB_KEY); } catch (e) { /* ignore */ }
    el.progressSection.classList.add('hidden');
    // Pipeline-Bereich bleibt sichtbar; Events bleiben in der Liste
    resetButton();
    reloadPendingCount();
  }

  function resetButton() {
    isProcessing = false;
    currentJobId = null;
    el.startBatchBtn.disabled = false;
    el.btnIcon.innerHTML = '&#x1F680;';
    el.btnText.textContent = 'Start Batch';
  }

  async function reloadPendingCount() {
    try {
      const res = await fetch(`${API_URL}/api/admin/pending-ai-count`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      if (res.ok) {
        const pending = await res.json();
        const count = pending.data?.count || 0;
        el.pendingAiCount.textContent = count;
        updateButtonState(count);
        
        if (count > 0) {
          el.pendingCard.classList.remove('border-gray-300');
          el.pendingCard.classList.add('border-amber-400');
          el.noPendingHint?.classList.add('hidden');
        } else {
          el.pendingCard.classList.remove('border-amber-400');
          el.pendingCard.classList.add('border-gray-300');
          el.noPendingHint?.classList.remove('hidden');
        }
      }
    } catch (e) {
      console.error('Failed to reload pending count:', e);
    }
  }

  // ========================================
  // DIAGNOSTICS
  // ========================================
  async function loadDiagnostics() {
    const workerDot = document.getElementById('diag-worker-dot');
    const workerStatus = document.getElementById('diag-worker-status');
    const workerEl = document.getElementById('diag-worker');
    const redisDot = document.getElementById('diag-redis-dot');
    const redisStatus = document.getElementById('diag-redis-status');
    const redisEl = document.getElementById('diag-redis');
    const openaiDot = document.getElementById('diag-openai-dot');
    const openaiStatus = document.getElementById('diag-openai-status');
    const openaiEl = document.getElementById('diag-openai');

    try {
      const res = await fetch(`${API_URL}/api/admin/ai-worker/diagnostics`, {
        headers: { Authorization: `Bearer ${token}` }
      });

      if (!res.ok) throw new Error('Failed to fetch diagnostics');
      
      const { data, success } = await res.json();
      
      if (!success || !data.reachable) {
        throw new Error('AI-Worker nicht erreichbar');
      }

      // Worker (inline in Header)
      if (workerDot) workerDot.className = 'w-1.5 h-1.5 rounded-full bg-green-500';
      if (workerStatus) workerStatus.textContent = 'Ok';
      if (workerEl) workerEl.className = 'flex items-center gap-1.5 px-2.5 py-1 rounded-full bg-green-50 text-xs';

      // Redis (inline)
      const redisCheck = data.checks?.redis;
      if (redisCheck?.status === 'ok') {
        if (redisDot) redisDot.className = 'w-1.5 h-1.5 rounded-full bg-green-500';
        if (redisStatus) redisStatus.textContent = 'Ok';
        if (redisEl) redisEl.className = 'flex items-center gap-1.5 px-2.5 py-1 rounded-full bg-green-50 text-xs';
      } else {
        if (redisDot) redisDot.className = 'w-1.5 h-1.5 rounded-full bg-amber-500';
        if (redisStatus) redisStatus.textContent = '–';
        if (redisEl) redisEl.className = 'flex items-center gap-1.5 px-2.5 py-1 rounded-full bg-amber-50 text-xs';
      }

      // OpenAI (inline) – fuer Button-Sperre und Fehlermeldung
      const openaiCheck = data.checks?.openai;
      openaiOk = openaiCheck?.status === 'ok';
      if (openaiCheck?.status === 'ok') {
        if (openaiDot) openaiDot.className = 'w-1.5 h-1.5 rounded-full bg-green-500';
        if (openaiStatus) openaiStatus.textContent = 'Ok';
        if (openaiEl) openaiEl.className = 'flex items-center gap-1.5 px-2.5 py-1 rounded-full bg-green-50 text-xs';
      } else {
        const err = (openaiCheck?.error || '').toLowerCase();
        const isQuota = err.includes('429') || err.includes('quota') || err.includes('insufficient_quota');
        if (openaiDot) openaiDot.className = 'w-1.5 h-1.5 rounded-full bg-red-500';
        if (openaiStatus) openaiStatus.textContent = isQuota ? 'Kontingent' : 'Nicht verfuegbar';
        if (openaiEl) openaiEl.className = 'flex items-center gap-1.5 px-2.5 py-1 rounded-full bg-red-50 text-xs';
      }
      updateButtonState(lastPendingCount);
    } catch (e) {
      console.error('Diagnostics error:', e);
      openaiOk = false;
      updateButtonState(lastPendingCount);
      if (workerDot) workerDot.className = 'w-1.5 h-1.5 rounded-full bg-red-500';
      if (workerStatus) workerStatus.textContent = 'Fehler';
      if (workerEl) workerEl.className = 'flex items-center gap-1.5 px-2.5 py-1 rounded-full bg-red-50 text-xs';
    }
  }

  // ========================================
  // KEYBOARD NAVIGATION
  // ========================================
  document.addEventListener('keydown', (e) => {
    // Don't capture when typing in inputs
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;
    
    if (e.key === 'j' || e.key === 'ArrowDown') {
      e.preventDefault();
      navigateEvents(1);
    } else if (e.key === 'k' || e.key === 'ArrowUp') {
      e.preventDefault();
      navigateEvents(-1);
    } else if (e.key === 'Escape') {
      selectedEventId = null;
      el.detailEmpty.classList.remove('hidden');
      el.detailContent.classList.add('hidden');
      document.querySelectorAll('.event-list-item').forEach(item => item.classList.remove('event-list-item--selected'));
    } else if (e.key === 'c' && !e.ctrlKey && !e.metaKey) {
      document.getElementById('crawl-btn')?.click();
    }
  });

  function navigateEvents(direction) {
    if (events.length === 0) return;
    const currentIdx = events.findIndex(e => e.id === selectedEventId);
    let newIdx;
    if (currentIdx === -1) {
      newIdx = direction > 0 ? 0 : events.length - 1;
    } else {
      newIdx = currentIdx + direction;
      if (newIdx < 0) newIdx = events.length - 1;
      if (newIdx >= events.length) newIdx = 0;
    }
    selectEvent(events[newIdx].id);
    scrollEventIntoView(events[newIdx].id);
  }

  // ========================================
  // INIT
  // ========================================
  loadData();
  loadDiagnostics();
</script>

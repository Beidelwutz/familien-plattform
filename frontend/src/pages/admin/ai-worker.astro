---
import AdminLayout from '../../layouts/AdminLayout.astro';
const API_URL = import.meta.env.PUBLIC_API_URL || 'http://localhost:4000';
---

<AdminLayout title="AI Worker - kiezling Admin" currentPage="ai-worker">
  <div class="max-w-7xl mx-auto">
    <!-- Header -->
    <header class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4 mb-6">
      <div>
        <h1 class="text-2xl font-bold text-gray-900">AI Worker</h1>
        <p class="text-gray-500 text-sm mt-1">Pending-Events klassifizieren und Status setzen</p>
      </div>
      <div class="flex items-center gap-3">
        <div id="cost-badge" class="hidden px-3 py-1.5 rounded-full bg-purple-100 text-purple-700 text-sm font-medium">
          <span id="total-cost">$0.00</span>
        </div>
        <div id="health-badge" class="flex items-center gap-2 px-3 py-1.5 rounded-full bg-gray-100 text-gray-500 text-sm font-medium">
          <span id="health-dot" class="w-2 h-2 rounded-full bg-gray-400"></span>
          <span id="health-text">Pruefe...</span>
        </div>
      </div>
    </header>

    <!-- Loading State -->
    <div id="loading-state" class="text-center py-12">
      <div class="animate-spin inline-block w-8 h-8 border-4 border-primary-500 border-t-transparent rounded-full"></div>
      <p class="text-gray-500 mt-4">Lade Status...</p>
    </div>

    <!-- Content -->
    <div id="content" class="hidden space-y-6">
      <!-- Stats Row -->
      <div class="grid grid-cols-2 lg:grid-cols-5 gap-4">
        <div id="pending-card" class="bg-white rounded-2xl shadow-card p-4 border-l-4 border-gray-300">
          <p class="text-xs text-gray-500 font-medium">Pending AI</p>
          <p id="pending-ai-count" class="text-2xl font-bold text-gray-900 mt-1">--</p>
        </div>
        <div class="bg-white rounded-2xl shadow-card p-4">
          <p class="text-xs text-gray-500">Heute verarbeitet</p>
          <p id="processed-today" class="text-2xl font-bold text-gray-900 mt-1">--</p>
        </div>
        <div class="bg-white rounded-2xl shadow-card p-4">
          <p class="text-xs text-gray-500">Erfolgsrate</p>
          <p id="success-rate" class="text-2xl font-bold text-gray-900 mt-1">--%</p>
        </div>
        <div class="bg-white rounded-2xl shadow-card p-4">
          <p class="text-xs text-gray-500">Ã˜ Zeit/Event</p>
          <p id="avg-time" class="text-2xl font-bold text-gray-900 mt-1">--</p>
        </div>
        <div class="bg-white rounded-2xl shadow-card p-4">
          <p class="text-xs text-gray-500">Letzte Aktivitaet</p>
          <p id="last-processed-at" class="text-lg font-bold text-gray-900 mt-1">--</p>
        </div>
      </div>

      <!-- Batch Processing Controls -->
      <div class="bg-white rounded-2xl shadow-card p-6">
        <div class="flex flex-col sm:flex-row sm:items-center gap-4">
          <div class="flex-1">
            <div class="flex items-center justify-between mb-2">
              <label for="batch-slider" class="text-sm font-medium text-gray-700">Batch-Groesse</label>
              <span id="slider-value" class="text-sm font-bold text-primary-600 bg-primary-50 px-2 py-0.5 rounded">25</span>
            </div>
            <input 
              type="range" 
              id="batch-slider" 
              min="10" 
              max="100" 
              value="25" 
              step="5"
              class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider-thumb"
            />
          </div>
          <button 
            id="start-batch-btn" 
            class="px-6 py-3 bg-primary-500 hover:bg-primary-600 disabled:bg-gray-300 disabled:cursor-not-allowed text-white font-semibold rounded-xl transition-colors flex items-center gap-2"
          >
            <span id="btn-icon">&#x1F680;</span>
            <span id="btn-text">Start Batch</span>
          </button>
        </div>
        <p id="btn-hint" class="text-sm text-gray-500 mt-2 hidden"></p>
        <div id="no-pending-hint" class="hidden mt-3 p-3 bg-blue-50 border border-blue-200 rounded-lg text-sm text-blue-800">
          <strong>Warum keine Batches?</strong> Es gibt aktuell keine Events mit Status &quot;Pending AI&quot;. Neue solche Events entstehen durch <strong>Crawl/Ingest</strong> (Quellen crawlen). Sobald neue Rohdaten reinkommen, erscheinen sie hier und koennen verarbeitet werden.
        </div>
      </div>

      <!-- Progress Bar (shown during processing) -->
      <div id="progress-section" class="hidden bg-white rounded-2xl shadow-card p-4">
        <div class="flex items-center justify-between mb-2">
          <div class="flex items-center gap-4">
            <span id="progress-text" class="text-sm text-gray-600">0 / 0</span>
            <span id="progress-percent" class="text-sm font-bold text-primary-600">0%</span>
            <span id="elapsed-time" class="text-sm text-gray-400">0:00</span>
            <!-- Heartbeat Indicator -->
            <span id="heartbeat-indicator" class="flex items-center gap-1.5 text-xs px-2 py-1 rounded-full bg-green-100 text-green-700">
              <span id="heartbeat-dot" class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span>
              <span id="heartbeat-text">Aktiv</span>
            </span>
          </div>
          <div class="flex items-center gap-3">
            <!-- Summary badges -->
            <span class="text-xs px-2 py-1 rounded-full bg-green-100 text-green-700">
              <span id="stat-published">0</span> published
            </span>
            <span class="text-xs px-2 py-1 rounded-full bg-amber-100 text-amber-700">
              <span id="stat-review">0</span> review
            </span>
            <span class="text-xs px-2 py-1 rounded-full bg-red-100 text-red-700">
              <span id="stat-failed">0</span> failed
            </span>
            <button id="cancel-btn" class="px-3 py-1 text-sm text-red-600 hover:bg-red-50 rounded-lg transition-colors">
              Abbrechen
            </button>
          </div>
        </div>
        <div class="w-full bg-gray-200 rounded-full h-2 overflow-hidden">
          <div id="progress-bar" class="bg-primary-500 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
        <div id="redis-unavailable-banner" class="hidden mt-3 p-3 bg-amber-50 border border-amber-200 rounded-lg text-sm text-amber-800">
          <strong>Live-Fortschritt nicht verfuegbar.</strong> Redis ist nicht konfiguriert. Der Batch laeuft im Hintergrund weiter. Seite in ein paar Minuten neu laden fuer die Ergebnisse.
        </div>
        <div id="stale-job-banner" class="hidden mt-3 p-3 bg-red-50 border border-red-200 rounded-lg text-sm text-red-800">
          <strong>Job moeglicherweise gestoppt.</strong> Kein Heartbeat seit ueber 5 Minuten. Der Job wurde eventuell unterbrochen.
          <button id="retry-stale-btn" class="ml-2 underline hover:no-underline">Job abbrechen und neu starten</button>
        </div>
      </div>

      <!-- Event Pipeline (Split-View) -->
      <div id="pipeline-section" class="hidden">
        <div class="flex gap-4 h-[600px]">
          <!-- Left: Event List -->
          <div class="w-80 flex-shrink-0 bg-white rounded-2xl shadow-card flex flex-col">
            <div class="p-4 border-b border-gray-100">
              <h3 class="font-semibold text-gray-900">Event Pipeline</h3>
              <p class="text-xs text-gray-500 mt-1"><span id="list-count">0</span> Events</p>
            </div>
            <div id="event-list" class="flex-1 overflow-y-auto p-2 space-y-1">
              <!-- Event items will be inserted here -->
            </div>
          </div>

          <!-- Right: Detail Panel -->
          <div class="flex-1 bg-white rounded-2xl shadow-card flex flex-col overflow-hidden">
            <div id="detail-panel" class="flex-1 overflow-y-auto">
              <!-- Empty state -->
              <div id="detail-empty" class="flex items-center justify-center h-full text-gray-400">
                <div class="text-center">
                  <div class="text-4xl mb-2">&#x1F50D;</div>
                  <p>Waehle ein Event aus der Liste</p>
                </div>
              </div>
              <!-- Detail content (hidden by default) -->
              <div id="detail-content" class="hidden p-6">
                <!-- Header -->
                <div class="mb-6">
                  <div class="flex items-start justify-between gap-4">
                    <div class="min-w-0">
                      <h2 id="detail-title" class="text-xl font-bold text-gray-900 truncate">Event Title</h2>
                      <a id="detail-source-link" href="#" target="_blank" class="text-sm text-primary-600 hover:underline truncate block">
                        <span id="detail-source-name">Quelle</span>
                      </a>
                    </div>
                    <div id="detail-status-badge" class="flex-shrink-0 px-3 py-1 rounded-full text-sm font-medium">
                      waiting
                    </div>
                  </div>
                  <!-- Missing fields warning -->
                  <div id="detail-missing" class="hidden mt-3 p-3 bg-amber-50 rounded-lg">
                    <p class="text-sm text-amber-700 font-medium">Fehlende Felder:</p>
                    <p id="detail-missing-list" class="text-sm text-amber-600 mt-1"></p>
                  </div>
                </div>

                <!-- Fields Grid -->
                <div class="space-y-6">
                  <!-- Basic Info -->
                  <div>
                    <h4 class="text-sm font-semibold text-gray-700 mb-3 flex items-center gap-2">
                      <span>&#x1F4CB;</span> Basis-Informationen
                    </h4>
                    <div class="grid grid-cols-2 gap-3" id="fields-basic">
                      <!-- Fields will be inserted here -->
                    </div>
                  </div>

                  <!-- AI Classifications -->
                  <div id="section-ai" class="hidden">
                    <h4 class="text-sm font-semibold text-gray-700 mb-3 flex items-center gap-2">
                      <span>&#x1F916;</span> AI Klassifikation
                    </h4>
                    <div class="grid grid-cols-2 gap-3" id="fields-ai">
                      <!-- AI fields will be inserted here -->
                    </div>
                  </div>

                  <!-- AI Scores -->
                  <div id="section-scores" class="hidden">
                    <h4 class="text-sm font-semibold text-gray-700 mb-3 flex items-center gap-2">
                      <span>&#x1F4CA;</span> AI Scores
                    </h4>
                    <div class="grid grid-cols-2 gap-3" id="fields-scores">
                      <!-- Score bars will be inserted here -->
                    </div>
                  </div>

                  <!-- Meta Info -->
                  <div id="section-meta" class="hidden">
                    <h4 class="text-sm font-semibold text-gray-700 mb-3 flex items-center gap-2">
                      <span>&#x2699;</span> Verarbeitungs-Details
                    </h4>
                    <div class="grid grid-cols-4 gap-3 text-center" id="fields-meta">
                      <!-- Meta info will be inserted here -->
                    </div>
                  </div>

                  <!-- Error Info -->
                  <div id="section-error" class="hidden">
                    <div class="p-4 bg-red-50 rounded-lg">
                      <p class="text-sm font-medium text-red-700">Fehler bei der Verarbeitung</p>
                      <p id="error-message" class="text-sm text-red-600 mt-1"></p>
                      <p id="error-step" class="text-xs text-red-500 mt-2"></p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Diagnostics Section (collapsed by default) -->
      <details class="bg-white rounded-2xl shadow-card">
        <summary class="p-4 cursor-pointer font-semibold text-gray-900 hover:bg-gray-50 rounded-2xl">
          &#x1F50D; Diagnose
        </summary>
        <div class="px-6 pb-6">
          <div id="diagnostics-loading" class="text-center py-4">
            <div class="animate-spin inline-block w-6 h-6 border-2 border-primary-500 border-t-transparent rounded-full"></div>
          </div>
          <div id="diagnostics-content" class="hidden">
            <div class="grid grid-cols-3 gap-3 mb-4">
              <div id="diag-worker" class="p-3 rounded-xl bg-gray-50">
                <div class="flex items-center gap-2 mb-1">
                  <span id="diag-worker-dot" class="w-2.5 h-2.5 rounded-full bg-gray-400"></span>
                  <span class="text-sm font-medium text-gray-700">AI-Worker</span>
                </div>
                <span id="diag-worker-status" class="text-xs text-gray-500">Pruefe...</span>
              </div>
              <div id="diag-redis" class="p-3 rounded-xl bg-gray-50">
                <div class="flex items-center gap-2 mb-1">
                  <span id="diag-redis-dot" class="w-2.5 h-2.5 rounded-full bg-gray-400"></span>
                  <span class="text-sm font-medium text-gray-700">Redis</span>
                </div>
                <span id="diag-redis-status" class="text-xs text-gray-500">Pruefe...</span>
              </div>
              <div id="diag-openai" class="p-3 rounded-xl bg-gray-50">
                <div class="flex items-center gap-2 mb-1">
                  <span id="diag-openai-dot" class="w-2.5 h-2.5 rounded-full bg-gray-400"></span>
                  <span class="text-sm font-medium text-gray-700">OpenAI API</span>
                </div>
                <span id="diag-openai-status" class="text-xs text-gray-500">Pruefe...</span>
              </div>
            </div>
            <div class="text-xs text-gray-400 flex flex-wrap gap-4">
              <span>Worker: <span id="diag-worker-url" class="font-mono">--</span></span>
              <span>Version: <span id="diag-version" class="font-mono">--</span></span>
              <span>Budget: <span id="diag-budget" class="font-mono">--</span></span>
            </div>
          </div>
          <div id="diagnostics-error" class="hidden text-center py-4">
            <p class="text-red-500 text-sm">AI-Worker nicht erreichbar</p>
          </div>
        </div>
      </details>

      <!-- Quick Links -->
      <div class="flex flex-wrap gap-3">
        <a href="/admin/review?status=pending_ai" class="px-4 py-2 bg-amber-100 text-amber-700 rounded-lg hover:bg-amber-200 transition-colors text-sm font-medium">
          Pending-AI Events
        </a>
        <a href="/admin/review?status=pending_review" class="px-4 py-2 bg-blue-100 text-blue-700 rounded-lg hover:bg-blue-200 transition-colors text-sm font-medium">
          Review Queue
        </a>
        <a href="/admin/ai-usage" class="px-4 py-2 bg-purple-100 text-purple-700 rounded-lg hover:bg-purple-200 transition-colors text-sm font-medium">
          AI Usage Monitor
        </a>
      </div>
    </div>

    <!-- Error State -->
    <div id="error-state" class="hidden text-center py-12 bg-white rounded-2xl shadow-card">
      <p class="text-red-500 text-lg mb-4">Fehler beim Laden</p>
      <button onclick="loadData()" class="px-4 py-2 bg-primary-500 text-white rounded-lg hover:bg-primary-600">
        Erneut versuchen
      </button>
    </div>
  </div>
</AdminLayout>

<style>
  /* Custom slider styles */
  .slider-thumb {
    -webkit-appearance: none;
    appearance: none;
  }
  
  .slider-thumb::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #4f46e5;
    cursor: pointer;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
  
  .slider-thumb::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #4f46e5;
    cursor: pointer;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }

  /* Event list item styles */
  .event-list-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    border-radius: 0.5rem;
    cursor: pointer;
    transition: all 0.15s ease;
  }
  
  .event-list-item:hover {
    background: #f3f4f6;
  }
  
  .event-list-item--selected {
    background: #e0e7ff !important;
    border-left: 3px solid #4f46e5;
  }
  
  .event-list-item--waiting {
    opacity: 0.7;
  }
  
  .event-list-item--processing {
    background: #fef3c7;
    border-left: 3px solid #f59e0b;
  }
  
  .event-list-item--done {
    border-left: 3px solid #10b981;
  }
  
  .event-list-item--error {
    border-left: 3px solid #ef4444;
    background: #fef2f2;
  }
  
  .event-list-item--history {
    opacity: 0.5;
  }

  /* Status indicator */
  .status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
  }
  
  .status-dot--waiting { background: #9ca3af; }
  .status-dot--processing { background: #f59e0b; animation: pulse 1s infinite; }
  .status-dot--done { background: #10b981; }
  .status-dot--error { background: #ef4444; }
  
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  /* Field styles */
  .field-card {
    padding: 0.75rem;
    border-radius: 0.5rem;
    background: #f9fafb;
  }
  
  .field-card--added {
    background: #ecfdf5;
    border: 1px solid #a7f3d0;
  }
  
  .field-card--changed {
    background: #fffbeb;
    border: 1px solid #fde68a;
  }
  
  .field-card--empty {
    background: #f9fafb;
    border: 1px dashed #d1d5db;
  }

  .ai-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    font-size: 0.625rem;
    font-weight: 600;
    color: #7c3aed;
    background: #ede9fe;
    padding: 0.125rem 0.375rem;
    border-radius: 0.25rem;
    margin-left: 0.5rem;
  }

  /* Score bar */
  .score-bar-container {
    height: 8px;
    background: #e5e7eb;
    border-radius: 4px;
    overflow: hidden;
  }
  
  .score-bar-fill {
    height: 100%;
    border-radius: 4px;
    transition: width 0.3s ease;
  }
  
  .score-bar-fill--high { background: #10b981; }
  .score-bar-fill--medium { background: #f59e0b; }
  .score-bar-fill--low { background: #ef4444; }
</style>

<script is:inline define:vars={{ API_URL }}>
  const token = localStorage.getItem('auth_token');
  if (!token) {
    window.location.href = '/login?redirect=/admin/ai-worker';
  }

  // ========================================
  // STATE
  // ========================================
  let isProcessing = false;
  let isHistoryMode = false;
  let currentJobId = null;
  let events = [];
  let selectedEventId = null;
  let startTime = null;
  let elapsedInterval = null;
  
  // Polling with exponential backoff
  const POLL_MIN_INTERVAL = 1000;
  const POLL_MAX_INTERVAL = 5000;
  let pollInterval = POLL_MIN_INTERVAL;
  let pollTimeout = null;
  let lastChangedAt = null;
  let poll503Count = 0;
  const POLL_503_MAX = 2;

  // Heartbeat tracking for reliability
  let lastHeartbeatStatus = 'healthy'; // 'healthy' | 'warning' | 'critical'
  let lastHeartbeatAge = 0; // seconds since last heartbeat

  const AI_WORKER_JOB_KEY = 'ai-worker-active-job';

  // ========================================
  // DOM ELEMENTS
  // ========================================
  const el = {
    loadingState: document.getElementById('loading-state'),
    content: document.getElementById('content'),
    errorState: document.getElementById('error-state'),
    healthBadge: document.getElementById('health-badge'),
    healthDot: document.getElementById('health-dot'),
    healthText: document.getElementById('health-text'),
    costBadge: document.getElementById('cost-badge'),
    totalCost: document.getElementById('total-cost'),
    pendingCard: document.getElementById('pending-card'),
    pendingAiCount: document.getElementById('pending-ai-count'),
    processedToday: document.getElementById('processed-today'),
    successRate: document.getElementById('success-rate'),
    avgTime: document.getElementById('avg-time'),
    lastProcessedAt: document.getElementById('last-processed-at'),
    batchSlider: document.getElementById('batch-slider'),
    sliderValue: document.getElementById('slider-value'),
    startBatchBtn: document.getElementById('start-batch-btn'),
    btnIcon: document.getElementById('btn-icon'),
    btnText: document.getElementById('btn-text'),
    btnHint: document.getElementById('btn-hint'),
    noPendingHint: document.getElementById('no-pending-hint'),
    progressSection: document.getElementById('progress-section'),
    progressText: document.getElementById('progress-text'),
    progressPercent: document.getElementById('progress-percent'),
    progressBar: document.getElementById('progress-bar'),
    elapsedTime: document.getElementById('elapsed-time'),
    statPublished: document.getElementById('stat-published'),
    statReview: document.getElementById('stat-review'),
    statFailed: document.getElementById('stat-failed'),
    cancelBtn: document.getElementById('cancel-btn'),
    pipelineSection: document.getElementById('pipeline-section'),
    eventList: document.getElementById('event-list'),
    listCount: document.getElementById('list-count'),
    detailPanel: document.getElementById('detail-panel'),
    detailEmpty: document.getElementById('detail-empty'),
    detailContent: document.getElementById('detail-content'),
  };

  // ========================================
  // INITIALIZATION
  // ========================================
  el.batchSlider.addEventListener('input', (e) => {
    el.sliderValue.textContent = e.target.value;
  });
  
  el.startBatchBtn.addEventListener('click', startBatch);
  el.cancelBtn.addEventListener('click', cancelProcessing);

  // ========================================
  // LOAD INITIAL DATA
  // ========================================
  async function loadData() {
    el.loadingState.classList.remove('hidden');
    el.content.classList.add('hidden');
    el.errorState.classList.add('hidden');

    try {
      const [pendingRes, healthRes, statsRes] = await Promise.all([
        fetch(`${API_URL}/api/admin/pending-ai-count`, {
          headers: { Authorization: `Bearer ${token}` }
        }),
        fetch(`${API_URL}/api/admin/ai-worker/health`, {
          headers: { Authorization: `Bearer ${token}` }
        }).catch(() => null),
        fetch(`${API_URL}/api/admin/ai-worker/stats`, {
          headers: { Authorization: `Bearer ${token}` }
        }).catch(() => null),
      ]);

      if (!pendingRes.ok) throw new Error('Failed to load pending count');

      const pending = await pendingRes.json();
      const pendingCount = pending.data?.count || 0;
      el.pendingAiCount.textContent = pendingCount;

      // Update pending card styling und Hinweis bei 0
      if (pendingCount > 0) {
        el.pendingCard.classList.remove('border-gray-300');
        el.pendingCard.classList.add('border-amber-400');
        el.noPendingHint?.classList.add('hidden');
      } else {
        el.pendingCard.classList.remove('border-amber-400');
        el.pendingCard.classList.add('border-gray-300');
        el.noPendingHint?.classList.remove('hidden');
      }

      // Update worker health
      if (healthRes && healthRes.ok) {
        const healthData = await healthRes.json();
        if (healthData.success && healthData.data?.status === 'healthy') {
          setHealthStatus('ok');
        } else {
          setHealthStatus('degraded');
        }
      } else {
        setHealthStatus('error');
      }

      // Update stats
      if (statsRes && statsRes.ok) {
        const statsData = await statsRes.json();
        if (statsData.data) {
          el.processedToday.textContent = statsData.data.processedToday || 0;
          el.successRate.textContent = statsData.data.successRate ? `${statsData.data.successRate}%` : '--%';
          el.avgTime.textContent = statsData.data.avgProcessingTime ? `${statsData.data.avgProcessingTime}ms` : '--';
          
          if (statsData.data.lastProcessedAt) {
            el.lastProcessedAt.textContent = formatTimeAgo(new Date(statsData.data.lastProcessedAt));
          }
        }
      }

      updateButtonState(pendingCount);

      el.loadingState.classList.add('hidden');
      el.content.classList.remove('hidden');

      // Nach Refresh: Aktiven Job vom SERVER abfragen (nicht sessionStorage)
      // Dies ist die vertrauenswuerdige Quelle - DB-basiert mit Heartbeat
      try {
        const activeJobRes = await fetch(`${API_URL}/api/admin/ai-jobs/active`, {
          headers: { Authorization: `Bearer ${token}` }
        });
        
        if (activeJobRes.ok) {
          const { data: activeJob, stale_job_id } = await activeJobRes.json();
          
          // Handle stale job warning
          if (stale_job_id) {
            showStaleJobWarning(stale_job_id);
          }
          
          if (activeJob && activeJob.status === 'running') {
            // Aktiver Job gefunden - UI wiederherstellen
            currentJobId = activeJob.id;
            events = activeJob.events || [];
            // WICHTIG: startedAt vom Server nutzen fuer korrekte Laufzeit
            startTime = activeJob.startedAt ? new Date(activeJob.startedAt).getTime() : 
                        (activeJob.started_at ? new Date(activeJob.started_at).getTime() : Date.now());
            lastChangedAt = activeJob.last_updated_at || null;
            poll503Count = 0;
            lastHeartbeatStatus = activeJob.heartbeat_status || 'healthy';
            lastHeartbeatAge = activeJob.heartbeat_age_seconds || 0;
            
            document.getElementById('redis-unavailable-banner')?.classList.add('hidden');
            
            showPipeline();
            updateFromJobStatus(activeJob);
            renderEventList();
            updateHeartbeatIndicator(lastHeartbeatStatus, lastHeartbeatAge);
            
            // Sofort korrekte Laufzeit anzeigen (nicht 0:00)
            updateElapsedTime();
            
            const selectId = activeJob.currentEventId || (events[0] && events[0].id);
            if (selectId) selectEvent(selectId); else if (events[0]) selectEvent(events[0].id);
            el.listCount.textContent = events.length;
            
            isProcessing = true;
            el.startBatchBtn.disabled = true;
            el.btnIcon.innerHTML = '&#x23F3;';
            el.btnText.textContent = 'Verarbeite...';
            startPolling();
            startElapsedTimer();
            
            console.log(`Restored active job ${currentJobId} from server (heartbeat: ${lastHeartbeatStatus})`);
          }
        }
        
        // Fallback: sessionStorage fuer abgeschlossene Jobs (Historie)
        const stored = sessionStorage.getItem(AI_WORKER_JOB_KEY);
        if (stored && !isProcessing) {
          const { jobId: savedJobId } = JSON.parse(stored);
          if (savedJobId) {
            const jobRes = await fetch(`${API_URL}/api/admin/ai-job-status/${savedJobId}`, {
              headers: { Authorization: `Bearer ${token}` }
            });
            if (jobRes.ok) {
              const { data: jobData } = await jobRes.json();
              if (jobData && jobData.events && jobData.events.length > 0 && 
                  (jobData.status === 'completed' || jobData.status === 'failed')) {
                // Zeige abgeschlossenen Job als Historie
                currentJobId = jobData.id;
                events = jobData.events;
                isHistoryMode = true;
                
                showPipeline();
                updateFromJobStatus(jobData);
                renderEventList();
                const selectId = events[0]?.id;
                if (selectId) selectEvent(selectId);
                el.listCount.textContent = events.length;
                
                setTimeout(() => { el.progressSection.classList.add('hidden'); }, 500);
                sessionStorage.removeItem(AI_WORKER_JOB_KEY);
              } else {
                sessionStorage.removeItem(AI_WORKER_JOB_KEY);
              }
            } else {
              sessionStorage.removeItem(AI_WORKER_JOB_KEY);
            }
          }
        }
      } catch (restoreErr) {
        console.warn('Restore job failed:', restoreErr);
        try { sessionStorage.removeItem(AI_WORKER_JOB_KEY); } catch (e) { /* ignore */ }
      }
    } catch (e) {
      console.error('Load error:', e);
      el.loadingState.classList.add('hidden');
      el.errorState.classList.remove('hidden');
    }
  }

  function setHealthStatus(status) {
    const classes = {
      ok: ['bg-green-100', 'text-green-700'],
      degraded: ['bg-amber-100', 'text-amber-700'],
      error: ['bg-red-100', 'text-red-700'],
    };
    const dotClasses = {
      ok: 'bg-green-500',
      degraded: 'bg-amber-500',
      error: 'bg-red-500',
    };
    const texts = { ok: 'OK', degraded: 'Eingeschraenkt', error: 'Offline' };
    
    el.healthBadge.className = `flex items-center gap-2 px-3 py-1.5 rounded-full text-sm font-medium ${classes[status].join(' ')}`;
    el.healthDot.className = `w-2 h-2 rounded-full ${dotClasses[status]}`;
    el.healthText.textContent = texts[status];
  }

  function formatTimeAgo(date) {
    const diffMs = Date.now() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);
    
    if (diffMins < 1) return 'gerade eben';
    if (diffMins < 60) return `vor ${diffMins}m`;
    if (diffHours < 24) return `vor ${diffHours}h`;
    return `vor ${diffDays}d`;
  }

  // ========================================
  // HEARTBEAT INDICATOR (Vertrauenswuerdigkeit)
  // ========================================
  function updateHeartbeatIndicator(status, ageSeconds) {
    lastHeartbeatStatus = status;
    lastHeartbeatAge = ageSeconds;
    
    const indicator = document.getElementById('heartbeat-indicator');
    const dot = document.getElementById('heartbeat-dot');
    const text = document.getElementById('heartbeat-text');
    const staleBanner = document.getElementById('stale-job-banner');
    
    if (!indicator || !dot || !text) return;
    
    // Update based on status
    if (status === 'healthy') {
      indicator.className = 'flex items-center gap-1.5 text-xs px-2 py-1 rounded-full bg-green-100 text-green-700';
      dot.className = 'w-2 h-2 rounded-full bg-green-500 animate-pulse';
      text.textContent = 'Aktiv';
      staleBanner?.classList.add('hidden');
    } else if (status === 'warning') {
      const mins = Math.floor(ageSeconds / 60);
      indicator.className = 'flex items-center gap-1.5 text-xs px-2 py-1 rounded-full bg-amber-100 text-amber-700';
      dot.className = 'w-2 h-2 rounded-full bg-amber-500 animate-pulse';
      text.textContent = `Heartbeat vor ${mins}m`;
      staleBanner?.classList.add('hidden');
    } else if (status === 'critical') {
      const mins = Math.floor(ageSeconds / 60);
      indicator.className = 'flex items-center gap-1.5 text-xs px-2 py-1 rounded-full bg-red-100 text-red-700';
      dot.className = 'w-2 h-2 rounded-full bg-red-500';
      text.textContent = `Gestoppt? (${mins}m)`;
      staleBanner?.classList.remove('hidden');
    }
  }

  function showStaleJobWarning(staleJobId) {
    const staleBanner = document.getElementById('stale-job-banner');
    if (staleBanner) {
      staleBanner.classList.remove('hidden');
      // Setup retry button
      const retryBtn = document.getElementById('retry-stale-btn');
      if (retryBtn) {
        retryBtn.onclick = async () => {
          try {
            // Cancel the stale job
            await fetch(`${API_URL}/api/admin/ai-jobs/${staleJobId}/cancel`, {
              method: 'POST',
              headers: { Authorization: `Bearer ${token}` }
            });
            staleBanner.classList.add('hidden');
            window.location.reload();
          } catch (e) {
            console.error('Failed to cancel stale job:', e);
          }
        };
      }
    }
  }

  function updateButtonState(pendingCount) {
    if (pendingCount === 0) {
      el.startBatchBtn.disabled = true;
      el.btnHint.textContent = 'Keine Events in der Queue';
      el.btnHint.classList.remove('hidden');
    } else if (isProcessing) {
      el.startBatchBtn.disabled = true;
      el.btnHint.textContent = 'Verarbeitung laeuft...';
      el.btnHint.classList.remove('hidden');
    } else {
      el.startBatchBtn.disabled = false;
      el.btnHint.classList.add('hidden');
    }
  }

  // ========================================
  // BATCH PROCESSING
  // ========================================
  async function startBatch() {
    if (isProcessing) return;

    const limit = el.batchSlider.value;
    isProcessing = true;
    isHistoryMode = false;
    el.startBatchBtn.disabled = true;
    el.btnIcon.innerHTML = '&#x23F3;';
    el.btnText.textContent = 'Startet...';
    el.btnHint.classList.add('hidden');

    try {
      const res = await fetch(`${API_URL}/api/admin/process-pending-ai?limit=${limit}`, {
        method: 'POST',
        headers: { 
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      const data = await res.json();

      if (!res.ok) {
        // Handle 409 Conflict - Job already running
        if (res.status === 409 && data.activeJobId) {
          alert(`Ein AI-Batch laeuft bereits (Job: ${data.activeJobId}). ${data.message || ''}`);
          // Reload to show the running job
          window.location.reload();
          return;
        }
        throw new Error(data.error || 'Processing failed');
      }

      if (data.jobId && data.events && data.events.length > 0) {
        currentJobId = data.jobId;
        events = data.events;
        startTime = Date.now();
        lastChangedAt = null;
        pollInterval = POLL_MIN_INTERVAL;
        poll503Count = 0;
        lastHeartbeatStatus = 'healthy';
        lastHeartbeatAge = 0;
        document.getElementById('redis-unavailable-banner')?.classList.add('hidden');
        document.getElementById('stale-job-banner')?.classList.add('hidden');
        
        try {
          sessionStorage.setItem(AI_WORKER_JOB_KEY, JSON.stringify({ jobId: data.jobId, startedAt: startTime }));
        } catch (e) { /* ignore */ }
        
        showPipeline();
        renderEventList();
        selectEvent(events[0].id);
        updateHeartbeatIndicator('healthy', 0);
        startPolling();
        startElapsedTimer();
        
        el.btnText.textContent = 'Verarbeite...';
      } else {
        const count = data.pending_ai_count ?? 0;
        const hint = data.hint || 'Neue Events entstehen durch Crawl/Ingest (Quellen crawlen).';
        alert(`Keine Events zu verarbeiten.\n\nAktuell ${count} Event(s) mit Status "Pending AI".\n\n${hint}`);
        resetButton();
      }

    } catch (e) {
      console.error('Processing error:', e);
      alert('Fehler bei der Verarbeitung: ' + e.message);
      resetButton();
    }
  }

  function showPipeline() {
    el.progressSection.classList.remove('hidden');
    el.pipelineSection.classList.remove('hidden');
    el.progressBar.style.width = '0%';
    el.progressText.textContent = `0 / ${events.length}`;
    el.progressPercent.textContent = '0%';
    el.statPublished.textContent = '0';
    el.statReview.textContent = '0';
    el.statFailed.textContent = '0';
    el.elapsedTime.textContent = '0:00';
    el.listCount.textContent = events.length;
    el.costBadge.classList.add('hidden');
  }

  function renderEventList() {
    el.eventList.innerHTML = '';
    
    events.forEach(event => {
      const item = document.createElement('div');
      item.id = `event-item-${event.id}`;
      item.className = getEventItemClasses(event);
      item.onclick = () => selectEvent(event.id);
      
      item.innerHTML = `
        <span class="status-dot status-dot--${event.processing_status}"></span>
        <span class="flex-1 truncate text-sm">${escapeHtml(event.title)}</span>
        ${event.result_status ? `<span class="text-xs px-1.5 py-0.5 rounded ${getResultBadgeClass(event.result_status)}">${event.result_status}</span>` : ''}
      `;
      
      el.eventList.appendChild(item);
    });
  }

  function getEventItemClasses(event) {
    let classes = 'event-list-item';
    classes += ` event-list-item--${event.processing_status}`;
    if (event.id === selectedEventId) classes += ' event-list-item--selected';
    if (isHistoryMode) classes += ' event-list-item--history';
    return classes;
  }

  function getResultBadgeClass(status) {
    const map = {
      published: 'bg-green-100 text-green-700',
      pending_review: 'bg-amber-100 text-amber-700',
      rejected: 'bg-red-100 text-red-700',
      incomplete: 'bg-gray-100 text-gray-700',
      archived: 'bg-gray-100 text-gray-500',
    };
    return map[status] || 'bg-gray-100 text-gray-700';
  }

  function selectEvent(eventId) {
    selectedEventId = eventId;
    
    // Update list selection
    document.querySelectorAll('.event-list-item').forEach(item => {
      item.classList.remove('event-list-item--selected');
    });
    const selectedItem = document.getElementById(`event-item-${eventId}`);
    if (selectedItem) {
      selectedItem.classList.add('event-list-item--selected');
    }
    
    // Render detail panel
    renderDetailPanel();
  }

  function renderDetailPanel() {
    const event = events.find(e => e.id === selectedEventId);
    if (!event) {
      el.detailEmpty.classList.remove('hidden');
      el.detailContent.classList.add('hidden');
      return;
    }

    el.detailEmpty.classList.add('hidden');
    el.detailContent.classList.remove('hidden');

    // Header
    document.getElementById('detail-title').textContent = event.title;
    const sourceLink = document.getElementById('detail-source-link');
    const sourceName = document.getElementById('detail-source-name');
    if (event.source_url) {
      sourceLink.href = event.source_url;
      sourceLink.classList.remove('hidden');
      sourceName.textContent = event.source_name || event.source_url;
    } else {
      sourceLink.classList.add('hidden');
    }

    // Status badge
    const statusBadge = document.getElementById('detail-status-badge');
    statusBadge.textContent = event.processing_status;
    statusBadge.className = `flex-shrink-0 px-3 py-1 rounded-full text-sm font-medium ${getStatusBadgeClass(event.processing_status)}`;

    // Missing fields
    const missingSection = document.getElementById('detail-missing');
    if (event.missing_fields && event.missing_fields.length > 0) {
      missingSection.classList.remove('hidden');
      document.getElementById('detail-missing-list').textContent = event.missing_fields.join(', ');
    } else {
      missingSection.classList.add('hidden');
    }

    // Basic fields
    renderBasicFields(event);
    
    // AI fields
    renderAIFields(event);
    
    // Scores
    renderScores(event);
    
    // Meta
    renderMeta(event);
    
    // Error
    renderError(event);
  }

  function getStatusBadgeClass(status) {
    const map = {
      waiting: 'bg-gray-100 text-gray-600',
      processing: 'bg-amber-100 text-amber-700',
      done: 'bg-green-100 text-green-700',
      error: 'bg-red-100 text-red-700',
    };
    return map[status] || 'bg-gray-100 text-gray-600';
  }

  function renderBasicFields(event) {
    const container = document.getElementById('fields-basic');
    const existing = event.existing || {};
    const diff = event.diff || {};
    
    const fields = [
      { key: 'start_datetime', label: 'Datum', format: v => v ? formatDateTime(v) : null },
      { key: 'location_address', label: 'Ort' },
      { key: 'price_min', label: 'Preis Min', format: v => v !== null ? `${v} EUR` : null },
      { key: 'price_max', label: 'Preis Max', format: v => v !== null ? `${v} EUR` : null },
      { key: 'age_min', label: 'Alter Min', format: v => v !== null ? `${v}+` : null },
      { key: 'age_max', label: 'Alter Max', format: v => v !== null ? `bis ${v}` : null },
      { key: 'is_indoor', label: 'Indoor', format: v => v ? 'Ja' : 'Nein' },
      { key: 'is_outdoor', label: 'Outdoor', format: v => v ? 'Ja' : 'Nein' },
    ];
    
    container.innerHTML = fields.map(f => {
      const existingVal = existing[f.key];
      const diffEntry = diff[f.key];
      const displayVal = f.format ? f.format(existingVal) : existingVal;
      
      let cardClass = 'field-card';
      let valueHtml = '';
      let aiBadge = '';
      
      if (diffEntry) {
        if (diffEntry.type === 'added') {
          cardClass += ' field-card--added';
          const newVal = f.format ? f.format(diffEntry.new_value) : diffEntry.new_value;
          valueHtml = `<span class="text-green-700">${escapeHtml(String(newVal || '--'))}</span>`;
          aiBadge = '<span class="ai-badge">AI</span>';
        } else if (diffEntry.type === 'changed') {
          cardClass += ' field-card--changed';
          const oldVal = f.format ? f.format(diffEntry.old_value) : diffEntry.old_value;
          const newVal = f.format ? f.format(diffEntry.new_value) : diffEntry.new_value;
          valueHtml = `<span class="text-gray-400 line-through">${escapeHtml(String(oldVal || '--'))}</span> <span class="text-amber-700">${escapeHtml(String(newVal || '--'))}</span>`;
          aiBadge = '<span class="ai-badge">AI</span>';
        } else {
          valueHtml = `<span class="text-gray-900">${escapeHtml(String(displayVal || '--'))}</span>`;
        }
      } else if (displayVal === null || displayVal === undefined || displayVal === '') {
        cardClass += ' field-card--empty';
        valueHtml = '<span class="text-gray-400">--leer--</span>';
      } else {
        valueHtml = `<span class="text-gray-900">${escapeHtml(String(displayVal))}</span>`;
      }
      
      return `
        <div class="${cardClass}">
          <p class="text-xs text-gray-500 mb-1">${f.label}${aiBadge}</p>
          <p class="text-sm font-medium">${valueHtml}</p>
        </div>
      `;
    }).join('');
  }

  function renderAIFields(event) {
    const container = document.getElementById('fields-ai');
    const section = document.getElementById('section-ai');
    const proposed = event.proposed;
    
    if (!proposed) {
      section.classList.add('hidden');
      return;
    }
    
    section.classList.remove('hidden');
    
    const fields = [
      { key: 'categories', label: 'Kategorien', format: v => Array.isArray(v) ? v.join(', ') : v },
      { key: 'age_rating', label: 'Altersfreigabe' },
      { key: 'ai_summary_short', label: 'AI Zusammenfassung' },
      { key: 'ai_fit_blurb', label: 'Familien-Fit' },
    ];
    
    container.innerHTML = fields.map(f => {
      const val = proposed[f.key];
      const displayVal = f.format ? f.format(val) : val;
      
      if (!displayVal) return '';
      
      return `
        <div class="field-card field-card--added col-span-2">
          <p class="text-xs text-gray-500 mb-1">${f.label}<span class="ai-badge">AI</span></p>
          <p class="text-sm text-green-700">${escapeHtml(String(displayVal))}</p>
        </div>
      `;
    }).join('');
  }

  function renderScores(event) {
    const container = document.getElementById('fields-scores');
    const section = document.getElementById('section-scores');
    const proposed = event.proposed;
    
    if (!proposed || proposed.family_fit_score === null) {
      section.classList.add('hidden');
      return;
    }
    
    section.classList.remove('hidden');
    
    const scores = [
      { key: 'family_fit_score', label: 'Family Fit' },
      { key: 'relevance_score', label: 'Relevanz' },
      { key: 'quality_score', label: 'Qualitaet' },
      { key: 'stressfree_score', label: 'Stressfrei' },
    ];
    
    container.innerHTML = scores.map(s => {
      const val = proposed[s.key];
      if (val === null || val === undefined) return '';
      
      const colorClass = val >= 70 ? 'high' : val >= 40 ? 'medium' : 'low';
      
      return `
        <div class="field-card">
          <div class="flex justify-between items-center mb-2">
            <span class="text-xs text-gray-500">${s.label}</span>
            <span class="text-sm font-bold">${val}</span>
          </div>
          <div class="score-bar-container">
            <div class="score-bar-fill score-bar-fill--${colorClass}" style="width: ${val}%"></div>
          </div>
        </div>
      `;
    }).join('');
  }

  function renderMeta(event) {
    const container = document.getElementById('fields-meta');
    const section = document.getElementById('section-meta');
    const meta = event.meta;
    
    if (!meta) {
      section.classList.add('hidden');
      return;
    }
    
    section.classList.remove('hidden');
    
    container.innerHTML = `
      <div class="field-card">
        <p class="text-xs text-gray-500">Model</p>
        <p class="text-sm font-medium">${escapeHtml(meta.model || '--')}</p>
      </div>
      <div class="field-card">
        <p class="text-xs text-gray-500">Konfidenz</p>
        <p class="text-sm font-medium">${meta.confidence ? (meta.confidence * 100).toFixed(0) + '%' : '--'}</p>
      </div>
      <div class="field-card">
        <p class="text-xs text-gray-500">Kosten</p>
        <p class="text-sm font-medium">${meta.cost_usd ? '$' + meta.cost_usd.toFixed(4) : '--'}</p>
      </div>
      <div class="field-card">
        <p class="text-xs text-gray-500">Zeit</p>
        <p class="text-sm font-medium">${meta.processing_time_ms ? meta.processing_time_ms + 'ms' : '--'}</p>
      </div>
    `;
  }

  function renderError(event) {
    const section = document.getElementById('section-error');
    const error = event.error;
    
    if (!error) {
      section.classList.add('hidden');
      return;
    }
    
    section.classList.remove('hidden');
    document.getElementById('error-message').textContent = error.message || 'Unbekannter Fehler';
    document.getElementById('error-step').textContent = `Schritt: ${error.step || 'unbekannt'} | ${error.retryable ? 'Wiederholbar' : 'Nicht wiederholbar'}`;
  }

  function formatDateTime(isoString) {
    if (!isoString) return null;
    const d = new Date(isoString);
    return d.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit', year: '2-digit', hour: '2-digit', minute: '2-digit' });
  }

  function escapeHtml(str) {
    if (!str) return '';
    return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
  }

  // ========================================
  // POLLING
  // ========================================
  function startPolling() {
    pollJobStatus();
  }

  function stopPolling() {
    if (pollTimeout) {
      clearTimeout(pollTimeout);
      pollTimeout = null;
    }
  }

  async function pollJobStatus() {
    if (!currentJobId) return;

    try {
      const url = lastChangedAt 
        ? `${API_URL}/api/admin/ai-job-status/${currentJobId}?changed_since=${encodeURIComponent(lastChangedAt)}`
        : `${API_URL}/api/admin/ai-job-status/${currentJobId}`;
      
      const res = await fetch(url, {
        headers: { Authorization: `Bearer ${token}` }
      });

      if (res.status === 503) {
        poll503Count++;
        if (poll503Count >= POLL_503_MAX) {
          stopPolling();
          showRedisUnavailableBanner();
          return;
        }
        schedulePoll();
        return;
      }

      if (!res.ok) {
        console.error('Failed to poll job status');
        schedulePoll();
        return;
      }

      poll503Count = 0;
      const { data } = await res.json();
      if (!data) {
        schedulePoll();
        return;
      }

      // Check if there are changes
      if (data.last_updated_at !== lastChangedAt) {
        pollInterval = POLL_MIN_INTERVAL;
        lastChangedAt = data.last_updated_at;
        updateFromJobStatus(data);
      } else {
        pollInterval = Math.min(pollInterval * 1.5, POLL_MAX_INTERVAL);
      }

      if (data.status === 'completed' || data.status === 'failed') {
        // Final fetch to get all data
        const finalRes = await fetch(`${API_URL}/api/admin/ai-job-status/${currentJobId}`, {
          headers: { Authorization: `Bearer ${token}` }
        });
        if (finalRes.ok) {
          const { data: finalData } = await finalRes.json();
          updateFromJobStatus(finalData);
        }
        onJobComplete(data);
        return;
      }

      schedulePoll();

    } catch (e) {
      console.error('Polling error:', e);
      schedulePoll();
    }
  }

  function schedulePoll() {
    pollTimeout = setTimeout(pollJobStatus, pollInterval);
  }

  function showRedisUnavailableBanner() {
    const banner = document.getElementById('redis-unavailable-banner');
    if (banner) banner.classList.remove('hidden');
  }

  function updateFromJobStatus(data) {
    // Update progress
    const percent = data.total > 0 ? Math.round((data.processed / data.total) * 100) : 0;
    el.progressBar.style.width = `${percent}%`;
    el.progressText.textContent = `${data.processed} / ${data.total}`;
    el.progressPercent.textContent = `${percent}%`;

    // Update summary
    if (data.summary) {
      el.statPublished.textContent = data.summary.published || 0;
      el.statReview.textContent = data.summary.pending_review || 0;
      el.statFailed.textContent = data.summary.failed || 0;
    }

    // Update cost
    if (data.total_cost_usd > 0) {
      el.costBadge.classList.remove('hidden');
      el.totalCost.textContent = '$' + data.total_cost_usd.toFixed(3);
    }

    // Update heartbeat indicator (vertrauenswuerdiger Status)
    if (data.heartbeat_status !== undefined && data.heartbeat_age_seconds !== undefined) {
      updateHeartbeatIndicator(data.heartbeat_status, data.heartbeat_age_seconds);
    }

    // Handle stale status from server
    if (data.status === 'stale') {
      updateHeartbeatIndicator('critical', data.heartbeat_age_seconds || 300);
    }

    // Merge event updates
    if (data.events && data.events.length > 0) {
      data.events.forEach(updatedEvent => {
        const idx = events.findIndex(e => e.id === updatedEvent.id);
        if (idx !== -1) {
          events[idx] = { ...events[idx], ...updatedEvent };
        }
      });
      
      renderEventList();
      
      // Auto-select current processing event
      if (data.currentEventId && data.currentEventId !== selectedEventId) {
        selectEvent(data.currentEventId);
        scrollEventIntoView(data.currentEventId);
      } else if (selectedEventId) {
        renderDetailPanel();
      }
    }
  }

  function scrollEventIntoView(eventId) {
    const item = document.getElementById(`event-item-${eventId}`);
    if (item) {
      item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
  }

  // ========================================
  // ELAPSED TIMER
  // ========================================
  function startElapsedTimer() {
    if (elapsedInterval) clearInterval(elapsedInterval);
    elapsedInterval = setInterval(updateElapsedTime, 1000);
  }

  function stopElapsedTimer() {
    if (elapsedInterval) {
      clearInterval(elapsedInterval);
      elapsedInterval = null;
    }
  }

  function updateElapsedTime() {
    if (!startTime) return;
    const elapsed = Math.floor((Date.now() - startTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    el.elapsedTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
  }

  // ========================================
  // JOB COMPLETION
  // ========================================
  function onJobComplete(data) {
    stopPolling();
    stopElapsedTimer();
    isHistoryMode = true;
    try { sessionStorage.removeItem(AI_WORKER_JOB_KEY); } catch (e) { /* ignore */ }
    
    // Update UI to history mode
    renderEventList();
    
    // Hide progress after a moment
    setTimeout(() => {
      el.progressSection.classList.add('hidden');
    }, 2000);
    
    resetButton();
    reloadPendingCount();
  }

  async function cancelProcessing() {
    if (currentJobId) {
      try {
        await fetch(`${API_URL}/api/admin/ai-jobs/${currentJobId}/cancel`, {
          method: 'POST',
          headers: { Authorization: `Bearer ${token}` }
        });
      } catch (e) {
        console.error('Cancel job request failed:', e);
      }
      currentJobId = null;
    }
    stopPolling();
    stopElapsedTimer();
    try { sessionStorage.removeItem(AI_WORKER_JOB_KEY); } catch (e) { /* ignore */ }
    el.progressSection.classList.add('hidden');
    el.pipelineSection.classList.add('hidden');
    resetButton();
    reloadPendingCount();
  }

  function resetButton() {
    isProcessing = false;
    currentJobId = null;
    el.startBatchBtn.disabled = false;
    el.btnIcon.innerHTML = '&#x1F680;';
    el.btnText.textContent = 'Start Batch';
  }

  async function reloadPendingCount() {
    try {
      const res = await fetch(`${API_URL}/api/admin/pending-ai-count`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      if (res.ok) {
        const pending = await res.json();
        const count = pending.data?.count || 0;
        el.pendingAiCount.textContent = count;
        updateButtonState(count);
        
        if (count > 0) {
          el.pendingCard.classList.remove('border-gray-300');
          el.pendingCard.classList.add('border-amber-400');
          el.noPendingHint?.classList.add('hidden');
        } else {
          el.pendingCard.classList.remove('border-amber-400');
          el.pendingCard.classList.add('border-gray-300');
          el.noPendingHint?.classList.remove('hidden');
        }
      }
    } catch (e) {
      console.error('Failed to reload pending count:', e);
    }
  }

  // ========================================
  // DIAGNOSTICS
  // ========================================
  async function loadDiagnostics() {
    const diagLoading = document.getElementById('diagnostics-loading');
    const diagContent = document.getElementById('diagnostics-content');
    const diagError = document.getElementById('diagnostics-error');
    
    diagLoading.classList.remove('hidden');
    diagContent.classList.add('hidden');
    diagError.classList.add('hidden');

    try {
      const res = await fetch(`${API_URL}/api/admin/ai-worker/diagnostics`, {
        headers: { Authorization: `Bearer ${token}` }
      });

      if (!res.ok) throw new Error('Failed to fetch diagnostics');
      
      const { data, success } = await res.json();
      
      if (!success || !data.reachable) {
        throw new Error('AI-Worker nicht erreichbar');
      }

      // Update worker status
      const workerDot = document.getElementById('diag-worker-dot');
      const workerStatus = document.getElementById('diag-worker-status');
      if (data.reachable) {
        workerDot.className = 'w-2.5 h-2.5 rounded-full bg-green-500';
        workerStatus.textContent = 'Verbunden';
        document.getElementById('diag-worker').className = 'p-3 rounded-xl bg-green-50';
      }

      // Update Redis status
      const redisDot = document.getElementById('diag-redis-dot');
      const redisStatus = document.getElementById('diag-redis-status');
      const redisCheck = data.checks?.redis;
      if (redisCheck?.status === 'ok') {
        redisDot.className = 'w-2.5 h-2.5 rounded-full bg-green-500';
        redisStatus.textContent = 'Verbunden';
        document.getElementById('diag-redis').className = 'p-3 rounded-xl bg-green-50';
      } else {
        redisDot.className = 'w-2.5 h-2.5 rounded-full bg-amber-500';
        redisStatus.textContent = 'Nicht verfuegbar';
        document.getElementById('diag-redis').className = 'p-3 rounded-xl bg-amber-50';
      }

      // Update OpenAI status
      const openaiDot = document.getElementById('diag-openai-dot');
      const openaiStatus = document.getElementById('diag-openai-status');
      const openaiCheck = data.checks?.openai;
      if (openaiCheck?.status === 'ok') {
        openaiDot.className = 'w-2.5 h-2.5 rounded-full bg-green-500';
        openaiStatus.textContent = 'Erreichbar';
        document.getElementById('diag-openai').className = 'p-3 rounded-xl bg-green-50';
      } else {
        openaiDot.className = 'w-2.5 h-2.5 rounded-full bg-gray-400';
        openaiStatus.textContent = 'Nicht konfiguriert';
      }

      // Config info
      document.getElementById('diag-worker-url').textContent = data.worker_url || '--';
      document.getElementById('diag-version').textContent = data.basic?.version || '--';
      document.getElementById('diag-budget').textContent = data.metrics?.budget_status || '--';
      
      diagLoading.classList.add('hidden');
      diagContent.classList.remove('hidden');
      
    } catch (e) {
      console.error('Diagnostics error:', e);
      diagLoading.classList.add('hidden');
      diagError.classList.remove('hidden');
    }
  }

  // ========================================
  // INIT
  // ========================================
  loadData();
  loadDiagnostics();
</script>

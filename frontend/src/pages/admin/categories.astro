---
import AdminLayout from '../../layouts/AdminLayout.astro';
const API_URL = import.meta.env.PUBLIC_API_URL || 'http://localhost:4000';
---

<AdminLayout title="Kategorien - kiezling Admin" currentPage="categories">
  <div class="max-w-7xl mx-auto">
    <!-- Header -->
    <header class="mb-6">
      <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <h1 class="text-2xl font-bold text-gray-900">Kategorien</h1>
          <p class="text-gray-500 text-sm mt-1">Kategorien f√ºr Events verwalten</p>
        </div>
        <button id="add-category-btn" class="btn-primary flex items-center gap-2 whitespace-nowrap">
          <span class="text-lg">+</span> Neue Kategorie
        </button>
      </div>
      
      <!-- Search -->
      <div class="mt-4 relative max-w-md">
        <svg class="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
        </svg>
        <input 
          type="text" 
          id="search-input" 
          placeholder="Kategorien durchsuchen..." 
          class="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent"
        />
      </div>
    </header>

    <!-- Loading State -->
    <div id="loading-state" class="text-center py-12">
      <div class="animate-spin inline-block w-8 h-8 border-4 border-primary-500 border-t-transparent rounded-full"></div>
      <p class="text-gray-500 mt-4">Lade Kategorien...</p>
    </div>

    <!-- Main Content: Two Column Layout -->
    <div id="main-content" class="hidden grid grid-cols-1 lg:grid-cols-5 gap-6">
      <!-- Left: Tree View (60%) -->
      <div class="lg:col-span-3">
        <div class="bg-white rounded-2xl shadow-card overflow-hidden">
          <div class="p-4 border-b border-gray-100 flex items-center justify-between">
            <h2 class="font-semibold text-gray-900">Kategorie-Baum</h2>
            <span id="category-count" class="text-sm text-gray-500">0 Kategorien</span>
          </div>
          
          <!-- Tree Container -->
          <div id="tree-container" class="p-2 max-h-[600px] overflow-y-auto">
            <!-- Tree items will be rendered here -->
          </div>
          
          <!-- Empty Tree State -->
          <div id="empty-tree" class="hidden p-8 text-center">
            <div class="text-4xl mb-3">üìÅ</div>
            <p class="text-gray-500 mb-4">Noch keine Kategorien vorhanden</p>
            <button class="btn-primary text-sm" onclick="document.getElementById('add-category-btn').click()">
              Erste Kategorie erstellen
            </button>
          </div>
        </div>
      </div>

      <!-- Right: Edit Form (40%) -->
      <div class="lg:col-span-2">
        <div class="bg-white rounded-2xl shadow-card overflow-hidden sticky top-24">
          <!-- Empty State -->
          <div id="form-empty-state" class="p-8 text-center">
            <div class="text-4xl mb-3">üëÜ</div>
            <p class="text-gray-700 font-medium">Kategorie ausw√§hlen</p>
            <p class="text-gray-500 text-sm mt-1">oder neue erstellen</p>
          </div>
          
          <!-- Edit Form -->
          <div id="edit-form-container" class="hidden">
            <div class="p-4 border-b border-gray-100 flex items-center justify-between">
              <h2 id="form-title" class="font-semibold text-gray-900">Kategorie bearbeiten</h2>
              <button id="form-close-btn" class="p-1 hover:bg-gray-100 rounded-lg transition-colors">
                <svg class="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
              </button>
            </div>
            
            <form id="category-form" class="p-4 space-y-4">
              <input type="hidden" id="edit-id" value="">
              
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">
                  Name <span class="text-red-500">*</span>
                </label>
                <input 
                  type="text" 
                  id="input-name" 
                  required 
                  class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent" 
                  placeholder="z.B. Spielpl√§tze"
                />
              </div>
              
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">
                  Slug <span class="text-red-500">*</span>
                </label>
                <input 
                  type="text" 
                  id="input-slug" 
                  required 
                  pattern="^[a-z0-9]+(?:-[a-z0-9]+)*$" 
                  class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent font-mono text-sm" 
                  placeholder="z.B. spielplaetze"
                />
                <p class="text-xs text-gray-500 mt-1">Nur Kleinbuchstaben, Zahlen und Bindestriche</p>
                <p id="slug-error" class="text-xs text-red-500 mt-1 hidden">Dieser Slug ist bereits vergeben</p>
              </div>
              
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">√úbergeordnete Kategorie</label>
                <select id="input-parent" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent">
                  <option value="">Keine (Hauptkategorie)</option>
                </select>
              </div>
              
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">Beschreibung</label>
                <textarea 
                  id="input-description" 
                  rows="3" 
                  class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent resize-none" 
                  placeholder="Optionale Beschreibung der Kategorie..."
                ></textarea>
              </div>
              
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">Icon / Emoji</label>
                <div class="flex gap-2">
                  <input 
                    type="text" 
                    id="input-icon" 
                    maxlength="10" 
                    class="w-20 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent text-2xl text-center" 
                    placeholder="üìÅ"
                  />
                  <div class="flex-1">
                    <div class="flex flex-wrap gap-1">
                      {['üé≠', 'üé®', 'üéµ', 'üèÉ', 'üìö', 'üéÆ', 'üçî', 'üå≥', 'üé™', 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶', 'üêæ', 'üéØ'].map(emoji => (
                        <button 
                          type="button" 
                          class="emoji-btn w-8 h-8 flex items-center justify-center hover:bg-gray-100 rounded transition-colors"
                          data-emoji={emoji}
                        >
                          {emoji}
                        </button>
                      ))}
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Form Actions -->
              <div class="flex gap-3 pt-4 border-t border-gray-100">
                <button 
                  type="submit" 
                  class="flex-1 px-4 py-2 bg-primary-500 text-white rounded-lg hover:bg-primary-600 font-medium transition-colors"
                >
                  Speichern
                </button>
                <button 
                  type="button" 
                  id="delete-btn" 
                  class="px-4 py-2 bg-red-50 text-red-600 rounded-lg hover:bg-red-100 font-medium transition-colors hidden"
                >
                  L√∂schen
                </button>
              </div>
            </form>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Delete Warning Modal -->
  <div id="delete-modal" class="fixed inset-0 bg-black/50 hidden items-center justify-center z-50 p-4">
    <div class="bg-white rounded-2xl max-w-md w-full p-6">
      <div class="flex items-start gap-4">
        <div class="w-12 h-12 bg-red-100 rounded-full flex items-center justify-center flex-shrink-0">
          <svg class="w-6 h-6 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
          </svg>
        </div>
        <div class="flex-1">
          <h3 class="text-lg font-semibold text-gray-900">Kategorie l√∂schen?</h3>
          <p id="delete-message" class="text-gray-600 mt-1">Diese Aktion kann nicht r√ºckg√§ngig gemacht werden.</p>
          <div id="delete-warning" class="mt-3 p-3 bg-red-50 border border-red-200 rounded-lg text-sm text-red-700 hidden">
            <!-- Warning content -->
          </div>
        </div>
      </div>
      <div class="flex gap-3 mt-6">
        <button id="delete-cancel" class="flex-1 px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 font-medium transition-colors">
          Abbrechen
        </button>
        <button id="delete-confirm" class="flex-1 px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 font-medium transition-colors">
          L√∂schen
        </button>
      </div>
    </div>
  </div>
</AdminLayout>

<style>
  /* Tree item styles */
  .tree-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.625rem 0.75rem;
    margin: 0.125rem 0;
    border-radius: 0.5rem;
    cursor: pointer;
    transition: background-color 0.15s;
  }
  
  .tree-item:hover {
    background-color: #f3f4f6;
  }
  
  .tree-item.selected {
    background-color: #e0e7ff;
  }
  
  .tree-item.selected:hover {
    background-color: #c7d2fe;
  }
  
  .tree-item-indent {
    width: 1.5rem;
    flex-shrink: 0;
  }
  
  .tree-chevron {
    width: 1.25rem;
    height: 1.25rem;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    color: #9ca3af;
    transition: transform 0.2s;
  }
  
  .tree-chevron.expanded {
    transform: rotate(90deg);
  }
  
  .tree-chevron.hidden-chevron {
    visibility: hidden;
  }
  
  .tree-icon {
    font-size: 1.25rem;
    flex-shrink: 0;
  }
  
  .tree-name {
    flex: 1;
    font-weight: 500;
    color: #111827;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  
  .tree-badge {
    font-size: 0.75rem;
    padding: 0.125rem 0.5rem;
    background-color: #f3f4f6;
    color: #6b7280;
    border-radius: 9999px;
    flex-shrink: 0;
  }
  
  .tree-children {
    overflow: hidden;
  }
  
  .tree-children.collapsed {
    display: none;
  }
  
  /* Button styles */
  .btn-primary {
    background-color: #4f46e5;
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    font-weight: 500;
    transition: background-color 0.2s;
  }
  
  .btn-primary:hover {
    background-color: #4338ca;
  }
  
  /* Card shadow */
  .shadow-card {
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
  }
</style>

<script is:inline define:vars={{ API_URL }}>
  // State
  let categories = [];
  let selectedCategoryId = null;
  let expandedNodes = new Set();
  let deleteTargetId = null;
  let isCreatingNew = false;
  let existingSlugs = new Set();

  // Elements
  const loadingState = document.getElementById('loading-state');
  const mainContent = document.getElementById('main-content');
  const treeContainer = document.getElementById('tree-container');
  const emptyTree = document.getElementById('empty-tree');
  const categoryCount = document.getElementById('category-count');
  const searchInput = document.getElementById('search-input');
  const formEmptyState = document.getElementById('form-empty-state');
  const editFormContainer = document.getElementById('edit-form-container');
  const formTitle = document.getElementById('form-title');
  const form = document.getElementById('category-form');
  const deleteBtn = document.getElementById('delete-btn');
  const deleteModal = document.getElementById('delete-modal');
  const deleteWarning = document.getElementById('delete-warning');
  const deleteMessage = document.getElementById('delete-message');
  const slugError = document.getElementById('slug-error');

  // Auth
  const token = localStorage.getItem('auth_token');

  // Slugify helper
  function slugify(text) {
    return text
      .toLowerCase()
      .replace(/[√§√Ñ]/g, 'ae')
      .replace(/[√∂√ñ]/g, 'oe')
      .replace(/[√º√ú]/g, 'ue')
      .replace(/√ü/g, 'ss')
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '');
  }

  // Build tree from flat list
  function buildTree(items) {
    const map = new Map();
    const roots = [];
    
    items.forEach(item => {
      map.set(item.id, { ...item, children: [] });
    });
    
    items.forEach(item => {
      const node = map.get(item.id);
      if (item.parent_id && map.has(item.parent_id)) {
        map.get(item.parent_id).children.push(node);
      } else {
        roots.push(node);
      }
    });
    
    // Sort by sort_order
    const sortNodes = (nodes) => {
      nodes.sort((a, b) => (a.sort_order || 0) - (b.sort_order || 0));
      nodes.forEach(node => sortNodes(node.children));
    };
    sortNodes(roots);
    
    return roots;
  }

  // Filter tree by search
  function filterTree(nodes, searchTerm) {
    if (!searchTerm) return nodes;
    
    const term = searchTerm.toLowerCase();
    
    function nodeMatches(node) {
      if (node.name_de.toLowerCase().includes(term)) return true;
      if (node.slug.toLowerCase().includes(term)) return true;
      return node.children.some(child => nodeMatches(child));
    }
    
    function filterNodes(nodes) {
      return nodes
        .filter(node => nodeMatches(node))
        .map(node => ({
          ...node,
          children: filterNodes(node.children)
        }));
    }
    
    return filterNodes(nodes);
  }

  // Render tree
  function renderTree(nodes, level = 0, searchTerm = '') {
    let html = '';
    
    nodes.forEach(node => {
      const hasChildren = node.children.length > 0;
      const isExpanded = expandedNodes.has(node.id);
      const isSelected = node.id === selectedCategoryId;
      const eventCount = node._count?.events || 0;
      
      html += `
        <div class="tree-node" data-id="${node.id}">
          <div class="tree-item ${isSelected ? 'selected' : ''}" style="padding-left: ${level * 1.5 + 0.75}rem">
            <span 
              class="tree-chevron ${hasChildren ? (isExpanded ? 'expanded' : '') : 'hidden-chevron'}"
              data-toggle="${node.id}"
            >
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
              </svg>
            </span>
            <span class="tree-icon">${node.icon || 'üìÅ'}</span>
            <span class="tree-name">${node.name_de}</span>
            <span class="tree-badge">${eventCount} Event${eventCount !== 1 ? 's' : ''}</span>
          </div>
          ${hasChildren ? `
            <div class="tree-children ${isExpanded ? '' : 'collapsed'}" data-parent="${node.id}">
              ${renderTree(node.children, level + 1, searchTerm)}
            </div>
          ` : ''}
        </div>
      `;
    });
    
    return html;
  }

  // Update tree display
  function updateTree() {
    const searchTerm = searchInput.value.trim();
    const tree = buildTree(categories);
    const filteredTree = filterTree(tree, searchTerm);
    
    if (filteredTree.length === 0) {
      treeContainer.classList.add('hidden');
      emptyTree.classList.remove('hidden');
    } else {
      treeContainer.classList.remove('hidden');
      emptyTree.classList.add('hidden');
      treeContainer.innerHTML = renderTree(filteredTree, 0, searchTerm);
      attachTreeEvents();
    }
    
    categoryCount.textContent = `${categories.length} Kategorie${categories.length !== 1 ? 'n' : ''}`;
  }

  // Attach tree event listeners
  function attachTreeEvents() {
    // Toggle expand/collapse
    treeContainer.querySelectorAll('.tree-chevron:not(.hidden-chevron)').forEach(chevron => {
      chevron.addEventListener('click', (e) => {
        e.stopPropagation();
        const id = chevron.dataset.toggle;
        if (expandedNodes.has(id)) {
          expandedNodes.delete(id);
        } else {
          expandedNodes.add(id);
        }
        updateTree();
      });
    });
    
    // Select category
    treeContainer.querySelectorAll('.tree-item').forEach(item => {
      item.addEventListener('click', (e) => {
        if (e.target.closest('.tree-chevron')) return;
        const node = item.closest('.tree-node');
        const id = node.dataset.id;
        selectCategory(id);
      });
    });
  }

  // Select category and show form
  function selectCategory(id) {
    selectedCategoryId = id;
    isCreatingNew = false;
    
    const category = categories.find(c => c.id === id);
    if (!category) return;
    
    formEmptyState.classList.add('hidden');
    editFormContainer.classList.remove('hidden');
    formTitle.textContent = 'Kategorie bearbeiten';
    deleteBtn.classList.remove('hidden');
    
    document.getElementById('edit-id').value = id;
    document.getElementById('input-name').value = category.name_de;
    document.getElementById('input-slug').value = category.slug;
    document.getElementById('input-slug').disabled = true;
    document.getElementById('input-parent').value = category.parent_id || '';
    document.getElementById('input-description').value = category.description || '';
    document.getElementById('input-icon').value = category.icon || '';
    
    // Update parent options (exclude self and descendants)
    updateParentOptions(id);
    
    // Hide slug error
    slugError.classList.add('hidden');
    
    updateTree();
  }

  // Show form for new category
  function showNewCategoryForm() {
    selectedCategoryId = null;
    isCreatingNew = true;
    
    formEmptyState.classList.add('hidden');
    editFormContainer.classList.remove('hidden');
    formTitle.textContent = 'Neue Kategorie';
    deleteBtn.classList.add('hidden');
    
    form.reset();
    document.getElementById('edit-id').value = '';
    document.getElementById('input-slug').disabled = false;
    
    // Update parent options (all available)
    updateParentOptions(null);
    
    // Hide slug error
    slugError.classList.add('hidden');
    
    updateTree();
  }

  // Update parent select options
  function updateParentOptions(excludeId) {
    const parentSelect = document.getElementById('input-parent');
    const tree = buildTree(categories);
    
    // Get all descendant IDs to exclude
    function getDescendantIds(nodes, ids = new Set()) {
      nodes.forEach(node => {
        ids.add(node.id);
        getDescendantIds(node.children, ids);
      });
      return ids;
    }
    
    let excludeIds = new Set();
    if (excludeId) {
      const node = categories.find(c => c.id === excludeId);
      if (node) {
        excludeIds.add(excludeId);
        const tree = buildTree(categories);
        function findNode(nodes) {
          for (const n of nodes) {
            if (n.id === excludeId) return n;
            const found = findNode(n.children);
            if (found) return found;
          }
          return null;
        }
        const targetNode = findNode(tree);
        if (targetNode) {
          getDescendantIds(targetNode.children, excludeIds);
        }
      }
    }
    
    // Render options with hierarchy
    function renderOptions(nodes, level = 0) {
      let html = '';
      nodes.forEach(node => {
        if (!excludeIds.has(node.id)) {
          const indent = '\u00A0\u00A0'.repeat(level);
          html += `<option value="${node.id}">${indent}${node.icon || 'üìÅ'} ${node.name_de}</option>`;
          html += renderOptions(node.children, level + 1);
        }
      });
      return html;
    }
    
    parentSelect.innerHTML = '<option value="">Keine (Hauptkategorie)</option>' + renderOptions(tree);
  }

  // Close form
  function closeForm() {
    selectedCategoryId = null;
    isCreatingNew = false;
    formEmptyState.classList.remove('hidden');
    editFormContainer.classList.add('hidden');
    updateTree();
  }

  // Load categories
  async function loadCategories() {
    try {
      const res = await fetch(`${API_URL}/api/admin/categories?flat=true`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      
      if (!res.ok) throw new Error('Failed to load');
      
      const data = await res.json();
      categories = data.data;
      
      // Build slug set for validation
      existingSlugs = new Set(categories.map(c => c.slug));
      
      // Expand all nodes by default initially
      if (expandedNodes.size === 0) {
        categories.forEach(c => {
          const hasChildren = categories.some(cat => cat.parent_id === c.id);
          if (hasChildren) expandedNodes.add(c.id);
        });
      }
      
      loadingState.classList.add('hidden');
      mainContent.classList.remove('hidden');
      mainContent.classList.add('grid');
      
      updateTree();
    } catch (e) {
      console.error(e);
      loadingState.innerHTML = '<p class="text-red-500">Fehler beim Laden der Kategorien</p>';
    }
  }

  // Save category
  async function saveCategory(e) {
    e.preventDefault();
    
    const editId = document.getElementById('edit-id').value;
    const name = document.getElementById('input-name').value.trim();
    const slug = document.getElementById('input-slug').value.trim();
    const parentId = document.getElementById('input-parent').value || null;
    const description = document.getElementById('input-description').value.trim() || null;
    const icon = document.getElementById('input-icon').value.trim() || null;
    
    // Validate slug uniqueness for new categories
    if (!editId && existingSlugs.has(slug)) {
      slugError.classList.remove('hidden');
      return;
    }
    slugError.classList.add('hidden');
    
    const data = {
      name_de: name,
      parent_id: parentId,
      description: description,
      icon: icon
    };
    
    if (!editId) {
      data.slug = slug;
    }
    
    try {
      const res = await fetch(
        editId 
          ? `${API_URL}/api/admin/categories/${editId}` 
          : `${API_URL}/api/admin/categories`,
        {
          method: editId ? 'PUT' : 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify(data),
        }
      );

      const result = await res.json();

      if (!res.ok) {
        if (result.error?.message?.includes('slug')) {
          slugError.classList.remove('hidden');
        } else {
          alert(result.error?.message || 'Fehler beim Speichern');
        }
        return;
      }

      closeForm();
      await loadCategories();
      
      // Select the newly created/updated category
      if (result.data?.id) {
        selectCategory(result.data.id);
      }
    } catch (e) {
      alert('Fehler beim Speichern');
    }
  }

  // Confirm delete
  function confirmDelete() {
    const category = categories.find(c => c.id === selectedCategoryId);
    if (!category) return;
    
    deleteTargetId = selectedCategoryId;
    const eventCount = category._count?.events || 0;
    const childCount = categories.filter(c => c.parent_id === selectedCategoryId).length;
    
    if (eventCount > 0 || childCount > 0) {
      let warningText = '';
      if (eventCount > 0) {
        warningText += `Diese Kategorie hat <strong>${eventCount} Event${eventCount !== 1 ? 's' : ''}</strong>. `;
      }
      if (childCount > 0) {
        warningText += `Diese Kategorie hat <strong>${childCount} Unterkategorie${childCount !== 1 ? 'n' : ''}</strong>. `;
      }
      warningText += 'Die Kategorie kann nicht gel√∂scht werden, solange sie Events oder Unterkategorien enth√§lt.';
      
      deleteWarning.innerHTML = warningText;
      deleteWarning.classList.remove('hidden');
      document.getElementById('delete-confirm').disabled = true;
      document.getElementById('delete-confirm').classList.add('opacity-50', 'cursor-not-allowed');
    } else {
      deleteWarning.classList.add('hidden');
      document.getElementById('delete-confirm').disabled = false;
      document.getElementById('delete-confirm').classList.remove('opacity-50', 'cursor-not-allowed');
    }
    
    deleteMessage.textContent = `M√∂chten Sie "${category.name_de}" wirklich l√∂schen?`;
    deleteModal.classList.remove('hidden');
    deleteModal.classList.add('flex');
  }

  // Execute delete
  async function executeDelete() {
    if (!deleteTargetId) return;
    
    try {
      const res = await fetch(`${API_URL}/api/admin/categories/${deleteTargetId}`, {
        method: 'DELETE',
        headers: { Authorization: `Bearer ${token}` },
      });

      if (!res.ok) {
        const result = await res.json();
        alert(result.error?.message || 'Fehler beim L√∂schen');
        return;
      }

      closeDeleteModal();
      closeForm();
      await loadCategories();
    } catch (e) {
      alert('Fehler beim L√∂schen');
    }
  }

  // Close delete modal
  function closeDeleteModal() {
    deleteModal.classList.add('hidden');
    deleteModal.classList.remove('flex');
    deleteTargetId = null;
  }

  // Event listeners
  document.getElementById('add-category-btn').addEventListener('click', showNewCategoryForm);
  document.getElementById('form-close-btn').addEventListener('click', closeForm);
  form.addEventListener('submit', saveCategory);
  deleteBtn.addEventListener('click', confirmDelete);
  document.getElementById('delete-cancel').addEventListener('click', closeDeleteModal);
  document.getElementById('delete-confirm').addEventListener('click', executeDelete);

  // Auto-generate slug from name
  document.getElementById('input-name').addEventListener('input', (e) => {
    const slugInput = document.getElementById('input-slug');
    if (!slugInput.disabled && !slugInput.dataset.manual) {
      slugInput.value = slugify(e.target.value);
      // Check if slug exists
      if (existingSlugs.has(slugInput.value)) {
        slugError.classList.remove('hidden');
      } else {
        slugError.classList.add('hidden');
      }
    }
  });

  document.getElementById('input-slug').addEventListener('input', (e) => {
    const slugInput = e.target;
    slugInput.dataset.manual = 'true';
    // Check if slug exists
    if (existingSlugs.has(slugInput.value)) {
      slugError.classList.remove('hidden');
    } else {
      slugError.classList.add('hidden');
    }
  });

  // Emoji picker
  document.querySelectorAll('.emoji-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.getElementById('input-icon').value = btn.dataset.emoji;
    });
  });

  // Search
  searchInput.addEventListener('input', () => {
    // Expand all when searching
    if (searchInput.value.trim()) {
      categories.forEach(c => expandedNodes.add(c.id));
    }
    updateTree();
  });

  // Close modal on escape
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      closeDeleteModal();
    }
  });

  // Close modal on backdrop click
  deleteModal.addEventListener('click', (e) => {
    if (e.target === deleteModal) {
      closeDeleteModal();
    }
  });

  // Initial load
  loadCategories();
</script>
